"""
This type stub file was generated by pyright.
"""

from collections.abc import Collection, Sequence
from typing import TYPE_CHECKING, Any

from airflow.datasets import BaseDataset
from airflow.models.dataset import DatasetEvent
from airflow.timetables.base import DagRunInfo, DataInterval, TimeRestriction, Timetable
from airflow.utils.types import DagRunType
from pendulum import DateTime
from sqlalchemy import Session

if TYPE_CHECKING: ...

class _TrivialTimetable(Timetable):
    """Some code reuse for "trivial" timetables that has nothing complex."""

    periodic = ...
    run_ordering: Sequence[str] = ...
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    def __eq__(self, other: Any) -> bool:
        """
        As long as *other* is of the same type.

        This is only for testing purposes and should not be relied on otherwise.
        """
        ...

    def serialize(self) -> dict[str, Any]: ...
    def infer_manual_data_interval(self, *, run_after: DateTime) -> DataInterval: ...

class NullTimetable(_TrivialTimetable):
    """
    Timetable that never schedules anything.

    This corresponds to ``schedule=None``.
    """

    can_be_scheduled = ...
    description: str = ...
    @property
    def summary(self) -> str: ...
    def next_dagrun_info(
        self,
        *,
        last_automated_data_interval: DataInterval | None,
        restriction: TimeRestriction,
    ) -> DagRunInfo | None: ...

class OnceTimetable(_TrivialTimetable):
    """
    Timetable that schedules the execution once as soon as possible.

    This corresponds to ``schedule="@once"``.
    """

    description: str = ...
    @property
    def summary(self) -> str: ...
    def next_dagrun_info(
        self,
        *,
        last_automated_data_interval: DataInterval | None,
        restriction: TimeRestriction,
    ) -> DagRunInfo | None: ...

class ContinuousTimetable(_TrivialTimetable):
    """
    Timetable that schedules continually, while still respecting start_date and end_date.

    This corresponds to ``schedule="@continuous"``.
    """

    description: str = ...
    active_runs_limit = ...
    @property
    def summary(self) -> str: ...
    def next_dagrun_info(
        self,
        *,
        last_automated_data_interval: DataInterval | None,
        restriction: TimeRestriction,
    ) -> DagRunInfo | None: ...

class DatasetTriggeredTimetable(_TrivialTimetable):
    """
    Timetable that never schedules anything.

    This should not be directly used anywhere, but only set if a DAG is triggered by datasets.

    :meta private:
    """

    description: str = ...
    def __init__(self, datasets: BaseDataset) -> None: ...
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    @property
    def summary(self) -> str: ...
    def serialize(self) -> dict[str, Any]: ...
    def generate_run_id(
        self,
        *,
        run_type: DagRunType,
        logical_date: DateTime,
        data_interval: DataInterval | None,
        session: Session | None = ...,
        events: Collection[DatasetEvent] | None = ...,
        **extra,
    ) -> str: ...
    def data_interval_for_events(
        self, logical_date: DateTime, events: Collection[DatasetEvent]
    ) -> DataInterval: ...
    def next_dagrun_info(
        self,
        *,
        last_automated_data_interval: DataInterval | None,
        restriction: TimeRestriction,
    ) -> DagRunInfo | None: ...
