"""
This type stub file was generated by pyright.
"""

import datetime
from typing import TYPE_CHECKING, Any, Union

from airflow.timetables._cron import CronMixin
from airflow.timetables.base import DagRunInfo, DataInterval, TimeRestriction, Timetable
from dateutil.relativedelta import relativedelta
from pendulum import DateTime

if TYPE_CHECKING: ...
Delta = Union[datetime.timedelta, relativedelta]

class _DataIntervalTimetable(Timetable):
    """
    Basis for timetable implementations that schedule data intervals.

    This kind of timetable classes create periodic data intervals from an
    underlying schedule representation (e.g. a cron expression, or a timedelta
    instance), and schedule a DagRun at the end of each interval.
    """

    def next_dagrun_info(
        self,
        *,
        last_automated_data_interval: DataInterval | None,
        restriction: TimeRestriction,
    ) -> DagRunInfo | None: ...

class CronDataIntervalTimetable(CronMixin, _DataIntervalTimetable):
    """
    Timetable that schedules data intervals with a cron expression.

    This corresponds to ``schedule=<cron>``, where ``<cron>`` is either
    a five/six-segment representation, or one of ``cron_presets``.

    The implementation extends on croniter to add timezone awareness. This is
    because croniter works only with naive timestamps, and cannot consider DST
    when determining the next/previous time.

    Don't pass ``@once`` in here; use ``OnceTimetable`` instead.
    """

    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    def serialize(self) -> dict[str, Any]: ...
    def infer_manual_data_interval(self, *, run_after: DateTime) -> DataInterval: ...

class DeltaDataIntervalTimetable(_DataIntervalTimetable):
    """
    Timetable that schedules data intervals with a time delta.

    This corresponds to ``schedule=<delta>``, where ``<delta>`` is
    either a ``datetime.timedelta`` or ``dateutil.relativedelta.relativedelta``
    instance.
    """

    def __init__(self, delta: Delta) -> None: ...
    @classmethod
    def deserialize(cls, data: dict[str, Any]) -> Timetable: ...
    def __eq__(self, other: Any) -> bool:
        """
        Return if the offsets match.

        This is only for testing purposes and should not be relied on otherwise.
        """
        ...

    @property
    def summary(self) -> str: ...
    def serialize(self) -> dict[str, Any]: ...
    def validate(self) -> None: ...
    def infer_manual_data_interval(self, run_after: DateTime) -> DataInterval: ...
