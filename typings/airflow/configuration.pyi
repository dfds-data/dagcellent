"""
This type stub file was generated by pyright.
"""

import builtins
import datetime
import functools
import os
import sys
from collections.abc import Generator, Iterable
from configparser import ConfigParser
from contextlib import contextmanager
from re import Pattern
from typing import (
    IO,
    TYPE_CHECKING,
    Any,
    Union,
    overload,
)

from airflow.auth.managers.base_auth_manager import BaseAuthManager
from airflow.secrets import BaseSecretsBackend
from airflow.utils.providers_configuration_loader import providers_configuration_loaded

if TYPE_CHECKING: ...
log = ...
if not sys.warnoptions: ...
_SQLITE3_VERSION_PATTERN = ...
ConfigType = Union[str, int, float, bool]
ConfigOptionsDictType = dict[str, ConfigType]
ConfigSectionSourcesType = dict[str, str | tuple[str, str]]
ConfigSourcesType = dict[str, ConfigSectionSourcesType]
ENV_VAR_PREFIX = ...

@overload
def expand_env_var(env_var: None) -> None: ...
@overload
def expand_env_var(env_var: str) -> str: ...
def expand_env_var(env_var: str | None) -> str | None:
    """
    Expand (potentially nested) env vars.

    Repeat and apply `expandvars` and `expanduser` until
    interpolation stops having any effect.
    """
    ...

def run_command(command: str) -> str:
    """Run command and returns stdout."""
    ...

def retrieve_configuration_description(
    include_airflow: bool = ...,
    include_providers: bool = ...,
    selected_provider: str | None = ...,
) -> dict[str, dict[str, Any]]:
    """
    Read Airflow configuration description from YAML file.

    :param include_airflow: Include Airflow configs
    :param include_providers: Include provider configs
    :param selected_provider: If specified, include selected provider only
    :return: Python dictionary containing configs & their info
    """
    ...

class AirflowConfigParser(ConfigParser):
    """
    Custom Airflow Configparser supporting defaults and deprecated options.

    This is a subclass of ConfigParser that supports defaults and deprecated options.

    The defaults are stored in the ``_default_values ConfigParser. The configuration description keeps
    description of all the options available in Airflow (description follow config.yaml.schema).

    :param default_config: default configuration (in the form of ini file).
    :param configuration_description: description of configuration to use
    """

    def __init__(self, default_config: str | None = ..., *args, **kwargs) -> None: ...
    def is_template(self, section: str, key) -> bool:
        """
        Return whether the value is templated.

        :param section: section of the config
        :param key: key in the section
        :return: True if the value is templated
        """
        ...

    def get_default_value(
        self, section: str, key: str, fallback: Any = ..., raw=..., **kwargs
    ) -> Any:
        """
        Retrieve default value from default config parser.

        This will retrieve the default value from the default config parser. Optionally a raw, stored
        value can be retrieved by setting skip_interpolation to True. This is useful for example when
        we want to write the default value to a file, and we don't want the interpolation to happen
        as it is going to be done later when the config is read.

        :param section: section of the config
        :param key: key to use
        :param fallback: fallback value to use
        :param raw: if raw, then interpolation will be reversed
        :param kwargs: other args
        :return:
        """
        ...

    def get_default_pre_2_7_value(self, section: str, key: str, **kwargs) -> Any:
        """Get pre 2.7 default config values."""
        ...

    @functools.cached_property
    def sensitive_config_values(self) -> builtins.set[tuple[str, str]]: ...

    deprecated_options: dict[tuple[str, str], tuple[str, str, str]] = ...
    many_to_one_deprecated_options: dict[
        tuple[str, str], list[tuple[str, str, str]]
    ] = ...
    deprecated_sections: dict[str, tuple[str, str]] = ...
    @functools.cached_property
    def inversed_deprecated_options(self):  # -> dict[tuple[str, str], tuple[str, str]]:
        ...
    @functools.cached_property
    def inversed_deprecated_sections(self):  # -> dict[str, str]:
        ...

    deprecated_values: dict[str, dict[str, tuple[Pattern, str, str]]] = ...
    _available_logging_levels = ...
    enums_options = ...
    upgraded_values: dict[tuple[str, str], str]
    def get_sections_including_defaults(self) -> list[str]:
        """
        Retrieve all sections from the configuration parser, including sections defined by built-in defaults.

        :return: list of section names
        """
        ...

    def get_options_including_defaults(self, section: str) -> list[str]:
        """
        Retrieve all possible option from the configuration parser for the section given.

        Includes options defined by built-in defaults.

        :return: list of option names for the section given
        """
        ...

    def optionxform(self, optionstr: str) -> str:
        """
        Transform option names on every read, get, or set operation.

        This changes from the default behaviour of ConfigParser from lower-casing
        to instead be case-preserving.

        :param optionstr:
        :return:
        """
        ...

    @contextmanager
    def make_sure_configuration_loaded(
        self, with_providers: bool
    ) -> Generator[None, None, None]:
        """
        Make sure configuration is loaded with or without providers.

        This happens regardless if the provider configuration has been loaded before or not.
        Restores configuration to the state before entering the context.

        :param with_providers: whether providers should be loaded
        """
        ...

    def write(
        self,
        file: IO[str],
        section: str | None = ...,
        include_examples: bool = ...,
        include_descriptions: bool = ...,
        include_sources: bool = ...,
        include_env_vars: bool = ...,
        include_providers: bool = ...,
        comment_out_everything: bool = ...,
        hide_sensitive_values: bool = ...,
        extra_spacing: bool = ...,
        only_defaults: bool = ...,
        **kwargs: Any,
    ) -> None:
        """
        Write configuration with comments and examples to a file.

        :param file: file to write to
        :param section: section of the config to write, defaults to all sections
        :param include_examples: Include examples in the output
        :param include_descriptions: Include descriptions in the output
        :param include_sources: Include the source of each config option
        :param include_env_vars: Include environment variables corresponding to each config option
        :param include_providers: Include providers configuration
        :param comment_out_everything: Comment out all values
        :param hide_sensitive_values: Include sensitive values in the output
        :param extra_spacing: Add extra spacing before examples and after variables
        :param only_defaults: Only include default values when writing the config, not the actual values
        """
        ...

    def restore_core_default_configuration(self) -> None:
        """
        Restore default configuration for core Airflow.

        It does not restore configuration for providers. If you want to restore configuration for
        providers, you need to call ``load_providers_configuration`` method.
        """
        ...

    def validate(self):  # -> None:
        ...
    def mask_secrets(self):  # -> None:
        ...
    def get_mandatory_value(self, section: str, key: str, **kwargs) -> str: ...
    def get_mandatory_list_value(
        self, section: str, key: str, **kwargs
    ) -> list[str]: ...
    @overload
    def get(self, section: str, key: str, fallback: str = ..., **kwargs) -> str: ...
    @overload
    def get(self, section: str, key: str, **kwargs) -> str | None: ...
    def get(
        self,
        section: str,
        key: str,
        suppress_warnings: bool = ...,
        _extra_stacklevel: int = ...,
        **kwargs,
    ) -> str | None: ...
    def getboolean(self, section: str, key: str, **kwargs) -> bool: ...
    def getint(self, section: str, key: str, **kwargs) -> int: ...
    def getfloat(self, section: str, key: str, **kwargs) -> float: ...
    def getlist(self, section: str, key: str, delimiter=..., **kwargs):  # -> list[str]:
        ...
    def getimport(self, section: str, key: str, **kwargs) -> Any:
        """
        Read options, import the full qualified name, and return the object.

        In case of failure, it throws an exception with the key and section names

        :return: The object or None, if the option is empty
        """
        ...

    def getjson(
        self, section: str, key: str, fallback=..., **kwargs
    ) -> dict | list | str | int | float | None:
        """
        Return a config value parsed from a JSON string.

        ``fallback`` is *not* JSON parsed but used verbatim when no config value is given.
        """
        ...

    def gettimedelta(
        self, section: str, key: str, fallback: Any = ..., **kwargs
    ) -> datetime.timedelta | None:
        """
        Get the config value for the given section and key, and convert it into datetime.timedelta object.

        If the key is missing, then it is considered as `None`.

        :param section: the section from the config
        :param key: the key defined in the given section
        :param fallback: fallback value when no config value is given, defaults to None
        :raises AirflowConfigException: raised because ValueError or OverflowError
        :return: datetime.timedelta(seconds=<config_value>) or None
        """
        ...

    def read(
        self,
        filenames: (str | bytes | os.PathLike | Iterable[str | bytes | os.PathLike]),
        encoding=...,
    ):  # -> None:
        ...
    def read_dict(
        self, dictionary: dict[str, dict[str, Any]], source: str = ...
    ):  # -> None:
        """
        We define a different signature here to add better type hints and checking.

        :param dictionary: dictionary to read from
        :param source: source to be used to store the configuration
        :return:
        """
        ...

    def has_option(self, section: str, option: str) -> bool:
        """
        Check if option is defined.

        Uses self.get() to avoid reimplementing the priority order of config variables
        (env, config, cmd, defaults).

        :param section: section to get option from
        :param option: option to get
        :return:
        """
        ...

    def set(self, section: str, option: str, value: str | None = ...) -> None:
        """
        Set an option to the given value.

        This override just makes sure the section and option are lower case, to match what we do in `get`.
        """
        ...

    def remove_option(
        self, section: str, option: str, remove_default: bool = ...
    ):  # -> None:
        """
        Remove an option if it exists in config from a file or default config.

        If both of config have the same option, this removes the option
        in both configs unless remove_default=False.
        """
        ...

    def getsection(self, section: str) -> ConfigOptionsDictType | None:
        """
        Return the section as a dict.

        Values are converted to int, float, bool as required.

        :param section: section from the config
        """
        ...

    def as_dict(
        self,
        display_source: bool = ...,
        display_sensitive: bool = ...,
        raw: bool = ...,
        include_env: bool = ...,
        include_cmds: bool = ...,
        include_secret: bool = ...,
    ) -> ConfigSourcesType:
        """
        Return the current configuration as an OrderedDict of OrderedDicts.

        When materializing current configuration Airflow defaults are
        materialized along with user set configs. If any of the `include_*`
        options are False then the result of calling command or secret key
        configs do not override Airflow defaults and instead are passed through.
        In order to then avoid Airflow defaults from overwriting user set
        command or secret key configs we filter out bare sensitive_config_values
        that are set to Airflow defaults when command or secret key configs
        produce different values.

        :param display_source: If False, the option value is returned. If True,
            a tuple of (option_value, source) is returned. Source is either
            'airflow.cfg', 'default', 'env var', or 'cmd'.
        :param display_sensitive: If True, the values of options set by env
            vars and bash commands will be displayed. If False, those options
            are shown as '< hidden >'
        :param raw: Should the values be output as interpolated values, or the
            "raw" form that can be fed back in to ConfigParser
        :param include_env: Should the value of configuration from AIRFLOW__
            environment variables be included or not
        :param include_cmds: Should the result of calling any *_cmd config be
            set (True, default), or should the _cmd options be left as the
            command to run (False)
        :param include_secret: Should the result of calling any *_secret config be
            set (True, default), or should the _secret options be left as the
            path to get the secret from (False)
        :return: Dictionary, where the key is the name of the section and the content is
            the dictionary with the name of the parameter and its value.
        """
        ...

    @contextmanager
    def suppress_future_warnings(self):  # -> Generator[Self, Any, None]:
        ...
    def load_test_config(self):  # -> None:
        """
        Use test configuration rather than the configuration coming from airflow defaults.

        When running tests we use special the unit_test configuration to avoid accidental modifications and
        different behaviours when running the tests. Values for those test configuration are stored in
        the "unit_tests.cfg" configuration file in the ``airflow/config_templates`` folder
        and you need to change values there if you want to make some specific configuration to be used
        """
        ...

    def expand_all_configuration_values(self):  # -> None:
        """Expand all configuration values using global and local variables defined in this module."""
        ...

    def remove_all_read_configurations(self):  # -> None:
        """Remove all read configurations, leaving only default values in the config."""
        ...

    @property
    def providers_configuration_loaded(self) -> bool:
        """Checks if providers have been loaded."""
        ...

    def load_providers_configuration(self):  # -> None:
        """
        Load configuration for providers.

        This should be done after initial configuration have been performed. Initializing and discovering
        providers is an expensive operation and cannot be performed when we load configuration for the first
        time when airflow starts, because we initialize configuration very early, during importing of the
        `airflow` package and the module is not yet ready to be used when it happens and until configuration
        and settings are loaded. Therefore, in order to reload provider configuration we need to additionally
        load provider - specific configuration.
        """
        ...

    def __getstate__(self) -> dict[str, Any]:
        """Return the state of the object as a dictionary for pickling."""
        ...

    def __setstate__(self, state) -> None:
        """Restore the state of the object from a dictionary representation."""
        ...

def get_airflow_home() -> str:
    """Get path to Airflow Home."""
    ...

def get_airflow_config(airflow_home: str) -> str:
    """Get Path to airflow.cfg path."""
    ...

def get_all_expansion_variables() -> dict[str, Any]: ...
def create_default_config_parser(
    configuration_description: dict[str, dict[str, Any]],
) -> ConfigParser:
    """
    Create default config parser based on configuration description.

    It creates ConfigParser with all default values retrieved from the configuration description and
    expands all the variables from the global and local variables defined in this module.

    :param configuration_description: configuration description - retrieved from config.yaml files
        following the schema defined in "config.yml.schema.json" in the config_templates folder.
    :return: Default Config Parser that can be used to read configuration values from.
    """
    ...

def create_pre_2_7_defaults() -> ConfigParser:
    """
    Create parser using the old defaults from Airflow < 2.7.0.

    This is used in order to be able to fall-back to those defaults when old version of provider,
    not supporting "config contribution" is installed with Airflow 2.7.0+. This "default"
    configuration does not support variable expansion, those are pretty much hard-coded defaults '
    we want to fall-back to in such case.
    """
    ...

def write_default_airflow_configuration_if_needed() -> AirflowConfigParser: ...
def load_standard_airflow_configuration(
    airflow_config_parser: AirflowConfigParser,
):  # -> None:
    """
    Load standard airflow configuration.

    In case it finds that the configuration file is missing, it will create it and write the default
    configuration values there, based on defaults passed, and will add the comments and examples
    from the default configuration.

    :param airflow_config_parser: parser to which the configuration will be loaded

    """
    ...

def initialize_config() -> AirflowConfigParser:
    """
    Load the Airflow config files.

    Called for you automatically as part of the Airflow boot process.
    """
    ...

@providers_configuration_loaded
def write_webserver_configuration_if_needed(
    airflow_config_parser: AirflowConfigParser,
):  # -> None:
    ...
def make_group_other_inaccessible(file_path: str):  # -> None:
    ...
def get(*args, **kwargs) -> ConfigType | None:
    """Historical get."""
    ...

def getboolean(*args, **kwargs) -> bool:
    """Historical getboolean."""
    ...

def getfloat(*args, **kwargs) -> float:
    """Historical getfloat."""
    ...

def getint(*args, **kwargs) -> int:
    """Historical getint."""
    ...

def getsection(*args, **kwargs) -> ConfigOptionsDictType | None:
    """Historical getsection."""
    ...

def has_option(*args, **kwargs) -> bool:
    """Historical has_option."""
    ...

def remove_option(*args, **kwargs) -> bool:
    """Historical remove_option."""
    ...

def as_dict(*args, **kwargs) -> ConfigSourcesType:
    """Historical as_dict."""
    ...

def set(*args, **kwargs) -> None:
    """Historical set."""
    ...

def ensure_secrets_loaded() -> list[BaseSecretsBackend]:
    """
    Ensure that all secrets backends are loaded.

    If the secrets_backend_list contains only 2 default backends, reload it.
    """
    ...

def get_custom_secret_backend() -> BaseSecretsBackend | None:
    """Get Secret Backend if defined in airflow.cfg."""
    ...

def initialize_secrets_backends() -> list[BaseSecretsBackend]:
    """
    Initialize secrets backend.

    * import secrets backend classes
    * instantiate them and return them in a list
    """
    ...

_deprecated = ...

def __getattr__(name): ...
def initialize_auth_manager() -> BaseAuthManager:
    """
    Initialize auth manager.

    * import user manager class
    * instantiate it and return it
    """
    ...

AIRFLOW_HOME = ...
AIRFLOW_CONFIG = ...
_TEST_DAGS_FOLDER = ...
if os.path.exists(_TEST_DAGS_FOLDER):
    TEST_DAGS_FOLDER = ...
else:
    TEST_DAGS_FOLDER = ...
_TEST_PLUGINS_FOLDER = ...
if os.path.exists(_TEST_PLUGINS_FOLDER):
    TEST_PLUGINS_FOLDER = ...
else:
    TEST_PLUGINS_FOLDER = ...
SECRET_KEY = ...
FERNET_KEY = ...
WEBSERVER_CONFIG = ...
conf: AirflowConfigParser = ...
secrets_backend_list = ...
