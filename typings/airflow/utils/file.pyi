"""
This type stub file was generated by pyright.
"""

import os
import zipfile
from collections.abc import Generator
from pathlib import Path
from re import Pattern
from typing import NamedTuple, Protocol, overload

log = ...
MODIFIED_DAG_MODULE_NAME = ...

class _IgnoreRule(Protocol):
    """Interface for ignore rules for structural subtyping."""

    @staticmethod
    def compile(
        pattern: str, base_dir: Path, definition_file: Path
    ) -> _IgnoreRule | None:
        """
        Build an ignore rule from the supplied pattern.

        ``base_dir`` and ``definition_file`` should be absolute paths.
        """
        ...

    @staticmethod
    def match(path: Path, rules: list[_IgnoreRule]) -> bool:
        """Match a candidate absolute path against a list of rules."""
        ...

class _RegexpIgnoreRule(NamedTuple):
    """Typed namedtuple with utility functions for regexp ignore rules."""

    pattern: Pattern
    base_dir: Path
    @staticmethod
    def compile(
        pattern: str, base_dir: Path, definition_file: Path
    ) -> _IgnoreRule | None:
        """Build an ignore rule from the supplied regexp pattern and log a useful warning if it is invalid."""
        ...

    @staticmethod
    def match(path: Path, rules: list[_IgnoreRule]) -> bool:
        """Match a list of ignore rules against the supplied path."""
        ...

class _GlobIgnoreRule(NamedTuple):
    """Typed namedtuple with utility functions for glob ignore rules."""

    pattern: Pattern
    raw_pattern: str
    include: bool | None = ...
    relative_to: Path | None = ...
    @staticmethod
    def compile(pattern: str, _, definition_file: Path) -> _IgnoreRule | None:
        """Build an ignore rule from the supplied glob pattern and log a useful warning if it is invalid."""
        ...

    @staticmethod
    def match(path: Path, rules: list[_IgnoreRule]) -> bool:
        """Match a list of ignore rules against the supplied path."""
        ...

def TemporaryDirectory(*args, **kwargs):  # -> TemporaryDirectory[str]:
    """Use `tempfile.TemporaryDirectory`, this function is deprecated."""
    ...

def mkdirs(path, mode):  # -> None:
    """
    Create the directory specified by path, creating intermediate directories as necessary.

    If directory already exists, this is a no-op.

    :param path: The directory to create
    :param mode: The mode to give to the directory e.g. 0o755, ignores umask
    """
    ...

ZIP_REGEX = ...

@overload
def correct_maybe_zipped(fileloc: None) -> None: ...
@overload
def correct_maybe_zipped(fileloc: str | Path) -> str | Path: ...
def correct_maybe_zipped(fileloc: None | str | Path) -> None | str | Path:
    """If the path contains a folder with a .zip suffix, treat it as a zip archive and return path."""
    ...

def open_maybe_zipped(fileloc, mode=...):  # -> TextIOWrapper[IO[bytes]] | IO[Any]:
    """
    Open the given file.

    If the path contains a folder with a .zip suffix, then the folder
    is treated as a zip archive, opening the file inside the archive.

    :return: a file object, as in `open`, or as in `ZipFile.open`.
    """
    ...

def find_path_from_directory(
    base_dir_path: str | os.PathLike[str],
    ignore_file_name: str,
    ignore_file_syntax: str = ...,
) -> Generator[str, None, None]:
    """
    Recursively search the base path for a list of file paths that should not be ignored.

    :param base_dir_path: the base path to be searched
    :param ignore_file_name: the file name in which specifies the patterns of files/dirs to be ignored
    :param ignore_file_syntax: the syntax of patterns in the ignore file: regexp or glob

    :return: a generator of file paths.
    """
    ...

def list_py_file_paths(
    directory: str | os.PathLike[str] | None,
    safe_mode: bool = ...,
    include_examples: bool | None = ...,
) -> list[str]:
    """
    Traverse a directory and look for Python files.

    :param directory: the directory to traverse
    :param safe_mode: whether to use a heuristic to determine whether a file
        contains Airflow DAG definitions. If not provided, use the
        core.DAG_DISCOVERY_SAFE_MODE configuration setting. If not set, default
        to safe.
    :param include_examples: include example DAGs
    :return: a list of paths to Python files in the specified directory
    """
    ...

def find_dag_file_paths(
    directory: str | os.PathLike[str], safe_mode: bool
) -> list[str]:
    """Find file paths of all DAG files."""
    ...

COMMENT_PATTERN = ...

def might_contain_dag(
    file_path: str, safe_mode: bool, zip_file: zipfile.ZipFile | None = ...
) -> bool:
    """
    Check whether a Python file contains Airflow DAGs.

    When safe_mode is off (with False value), this function always returns True.

    If might_contain_dag_callable isn't specified, it uses airflow default heuristic
    """
    ...

def might_contain_dag_via_default_heuristic(
    file_path: str, zip_file: zipfile.ZipFile | None = ...
) -> bool:
    """
    Heuristic that guesses whether a Python file contains an Airflow DAG definition.

    :param file_path: Path to the file to be checked.
    :param zip_file: if passed, checks the archive. Otherwise, check local filesystem.
    :return: True, if file might contain DAGs.
    """
    ...

def iter_airflow_imports(file_path: str) -> Generator[str, None, None]:
    """Find Airflow modules imported in the given file."""
    ...

def get_unique_dag_module_name(file_path: str) -> str:
    """Return a unique module name in the format unusual_prefix_{sha1 of module's file path}_{original module name}."""
    ...
