"""
This type stub file was generated by pyright.
"""

from collections.abc import Collection
from datetime import datetime, timedelta

from airflow.typing_compat import Literal
from dateutil.relativedelta import relativedelta

cron_presets: dict[str, str] = ...

def date_range(
    start_date: datetime,
    end_date: datetime | None = ...,
    num: int | None = ...,
    delta: str | timedelta | relativedelta | None = ...,
) -> list[datetime]:
    """
    Get a list of dates in the specified range, separated by delta.

    .. code-block:: pycon
        >>> from airflow.utils.dates import date_range
        >>> from datetime import datetime, timedelta
        >>> date_range(datetime(2016, 1, 1), datetime(2016, 1, 3), delta=timedelta(1))
        [datetime.datetime(2016, 1, 1, 0, 0, tzinfo=Timezone('UTC')),
        datetime.datetime(2016, 1, 2, 0, 0, tzinfo=Timezone('UTC')),
        datetime.datetime(2016, 1, 3, 0, 0, tzinfo=Timezone('UTC'))]
        >>> date_range(datetime(2016, 1, 1), datetime(2016, 1, 3), delta="0 0 * * *")
        [datetime.datetime(2016, 1, 1, 0, 0, tzinfo=Timezone('UTC')),
        datetime.datetime(2016, 1, 2, 0, 0, tzinfo=Timezone('UTC')),
        datetime.datetime(2016, 1, 3, 0, 0, tzinfo=Timezone('UTC'))]
        >>> date_range(datetime(2016, 1, 1), datetime(2016, 3, 3), delta="0 0 0 * *")
        [datetime.datetime(2016, 1, 1, 0, 0, tzinfo=Timezone('UTC')),
        datetime.datetime(2016, 2, 1, 0, 0, tzinfo=Timezone('UTC')),
        datetime.datetime(2016, 3, 1, 0, 0, tzinfo=Timezone('UTC'))]

    :param start_date: anchor date to start the series from
    :param end_date: right boundary for the date range
    :param num: alternatively to end_date, you can specify the number of
        number of entries you want in the range. This number can be negative,
        output will always be sorted regardless
    :param delta: step length. It can be datetime.timedelta or cron expression as string
    """
    ...

def round_time(
    dt: datetime, delta: str | timedelta | relativedelta, start_date: datetime = ...
):  # -> datetime:
    """
    Return ``start_date + i * delta`` for given ``i`` where the result is closest to ``dt``.

    .. code-block:: pycon

        >>> round_time(datetime(2015, 1, 1, 6), timedelta(days=1))
        datetime.datetime(2015, 1, 1, 0, 0)
        >>> round_time(datetime(2015, 1, 2), relativedelta(months=1))
        datetime.datetime(2015, 1, 1, 0, 0)
        >>> round_time(
        ...     datetime(2015, 9, 16, 0, 0), timedelta(1), datetime(2015, 9, 14, 0, 0)
        ... )
        datetime.datetime(2015, 9, 16, 0, 0)
        >>> round_time(
        ...     datetime(2015, 9, 15, 0, 0), timedelta(1), datetime(2015, 9, 14, 0, 0)
        ... )
        datetime.datetime(2015, 9, 15, 0, 0)
        >>> round_time(
        ...     datetime(2015, 9, 14, 0, 0), timedelta(1), datetime(2015, 9, 14, 0, 0)
        ... )
        datetime.datetime(2015, 9, 14, 0, 0)
        >>> round_time(
        ...     datetime(2015, 9, 13, 0, 0), timedelta(1), datetime(2015, 9, 14, 0, 0)
        ... )
        datetime.datetime(2015, 9, 14, 0, 0)
    """
    ...

TimeUnit = Literal["days", "hours", "minutes", "seconds"]

def infer_time_unit(time_seconds_arr: Collection[float]) -> TimeUnit:
    """
    Determine the most appropriate time unit for given durations (in seconds).

    e.g. 5400 seconds => 'minutes', 36000 seconds => 'hours'
    """
    ...

def scale_time_units(
    time_seconds_arr: Collection[float], unit: TimeUnit
) -> Collection[float]:
    """Convert an array of time durations in seconds to the specified time unit."""
    ...

def days_ago(n, hour=..., minute=..., second=..., microsecond=...):  # -> datetime:
    """
    Get a datetime object representing *n* days ago.

    By default the time is set to midnight.
    """
    ...

def parse_execution_date(execution_date_str):  # -> DateTime:
    """Parse execution date string to datetime object."""
    ...

def datetime_to_nano(datetime) -> int:
    """Convert datetime to nanoseconds."""
    ...
