"""
This type stub file was generated by pyright.
"""

import contextlib
from collections.abc import Generator, Iterable
from typing import TYPE_CHECKING, Any, overload

from kubernetes.client.models.v1_pod import V1Pod
from sqlalchemy import PickleType
from sqlalchemy.exc import OperationalError
from sqlalchemy.orm import Query, Session
from sqlalchemy.sql import ColumnElement, Select
from sqlalchemy.sql.expression import ColumnOperators
from sqlalchemy.types import Text, TypeDecorator, TypeEngine

if TYPE_CHECKING: ...
log = ...

class UtcDateTime(TypeDecorator):
    """
    Similar to :class:`~sqlalchemy.types.TIMESTAMP` with ``timezone=True`` option, with some differences.

    - Never silently take naive :class:`~datetime.datetime`, instead it
      always raise :exc:`ValueError` unless time zone aware value.
    - :class:`~datetime.datetime` value's :attr:`~datetime.datetime.tzinfo`
      is always converted to UTC.
    - Unlike SQLAlchemy's built-in :class:`~sqlalchemy.types.TIMESTAMP`,
      it never return naive :class:`~datetime.datetime`, but time zone
      aware value, even with SQLite or MySQL.
    - Always returns TIMESTAMP in UTC.
    """

    impl = ...
    cache_ok = ...
    def process_bind_param(self, value, dialect):  # -> datetime | None:
        ...
    def process_result_value(self, value, dialect):
        """
        Process DateTimes from the DB making sure to always return UTC.

        Not using timezone.convert_to_utc as that converts to configured TIMEZONE
        while the DB might be running with some other setting. We assume UTC
        datetimes in the database.
        """
        ...

    def load_dialect_impl(self, dialect):  # -> TIMESTAMP | object | None:
        ...

class ExtendedJSON(TypeDecorator):
    """
    A version of the JSON column that uses the Airflow extended JSON serialization.

    See airflow.serialization.
    """

    impl = Text
    cache_ok = ...
    def load_dialect_impl(self, dialect) -> TypeEngine: ...
    def process_bind_param(self, value, dialect):  # -> Any | None:
        ...
    def process_result_value(self, value, dialect):  # -> Any | None:
        ...

def sanitize_for_serialization(
    obj: V1Pod,
):  # -> float | bool | bytes | str | int | list[Any] | tuple[Any, ...] | dict[Any, Any] | None:
    """
    Convert pod to dict.... but *safely*.

    When pod objects created with one k8s version are unpickled in a python
    env with a more recent k8s version (in which the object attrs may have
    changed) the unpickled obj may throw an error because the attr
    expected on new obj may not be there on the unpickled obj.

    This function still converts the pod to a dict; the only difference is
    it populates missing attrs with None. You may compare with
    https://github.com/kubernetes-client/python/blob/5a96bbcbe21a552cc1f9cda13e0522fafb0dbac8/kubernetes/client/api_client.py#L202

    If obj is None, return None.
    If obj is str, int, long, float, bool, return directly.
    If obj is datetime.datetime, datetime.date
        convert to string in iso8601 format.
    If obj is list, sanitize each element in the list.
    If obj is dict, return the dict.
    If obj is OpenAPI model, return the properties dict.

    :param obj: The data to serialize.
    :return: The serialized form of data.

    :meta private:
    """
    ...

def ensure_pod_is_valid_after_unpickling(pod: V1Pod) -> V1Pod | None:
    """
    Convert pod to json and back so that pod is safe.

    The pod_override in executor_config is a V1Pod object.
    Such objects created with one k8s version, when unpickled in
    an env with upgraded k8s version, may blow up when
    `to_dict` is called, because openapi client code gen calls
    getattr on all attrs in openapi_types for each object, and when
    new attrs are added to that list, getattr will fail.

    Here we re-serialize it to ensure it is not going to blow up.

    :meta private:
    """
    ...

class ExecutorConfigType(PickleType):
    """
    Adds special handling for K8s executor config.

    If we unpickle a k8s object that was pickled under an earlier k8s library version, then
    the unpickled object may throw an error when to_dict is called.  To be more tolerant of
    version changes we convert to JSON using Airflow's serializer before pickling.
    """

    cache_ok = ...
    def bind_processor(self, dialect):  # -> Callable[..., Any]:
        ...
    def result_processor(
        self, dialect, coltype
    ):  # -> Callable[..., dict[Any, Any] | Any | None]:
        ...
    def compare_values(self, x, y):  # -> Literal[False]:
        """
        Compare x and y using self.comparator if available. Else, use __eq__.

        The TaskInstance.executor_config attribute is a pickled object that may contain kubernetes objects.

        If the installed library version has changed since the object was originally pickled,
        due to the underlying ``__eq__`` method on these objects (which converts them to JSON),
        we may encounter attribute errors. In this case we should replace the stored object.

        From https://github.com/apache/airflow/pull/24356 we use our serializer to store
        k8s objects, but there could still be raw pickled k8s objects in the database,
        stored from earlier version, so we still compare them defensively here.
        """
        ...

class Interval(TypeDecorator):
    """Base class representing a time interval."""

    impl = Text
    cache_ok = ...
    attr_keys = ...
    def process_bind_param(self, value, dialect):  # -> str:
        ...
    def process_result_value(
        self, value, dialect
    ):  # -> relativedelta | timedelta | Any:
        ...

def nulls_first(col, session: Session) -> dict[str, Any]:
    """
    Specify *NULLS FIRST* to the column ordering.

    This is only done to Postgres, currently the only backend that supports it.
    Other databases do not need it since NULL values are considered lower than
    any other values, and appear first when the order is ASC (ascending).
    """
    ...

USE_ROW_LEVEL_LOCKING: bool = ...

def with_row_locks(
    query: Query,
    session: Session,
    *,
    nowait: bool = ...,
    skip_locked: bool = ...,
    **kwargs,
) -> Query:
    """
    Apply with_for_update to the SQLAlchemy query if row level locking is in use.

    This wrapper is needed so we don't use the syntax on unsupported database
    engines. In particular, MySQL (prior to 8.0) and MariaDB do not support
    row locking, where we do not support nor recommend running HA scheduler. If
    a user ignores this and tries anyway, everything will still work, just
    slightly slower in some circumstances.

    See https://jira.mariadb.org/browse/MDEV-13115

    :param query: An SQLAlchemy Query object
    :param session: ORM Session
    :param nowait: If set to True, will pass NOWAIT to supported database backends.
    :param skip_locked: If set to True, will pass SKIP LOCKED to supported database backends.
    :param kwargs: Extra kwargs to pass to with_for_update (of, nowait, skip_locked, etc)
    :return: updated query
    """
    ...

@contextlib.contextmanager
def lock_rows(query: Query, session: Session) -> Generator[None, None, None]:
    """
    Lock database rows during the context manager block.

    This is a convenient method for ``with_row_locks`` when we don't need the
    locked rows.

    :meta private:
    """
    ...

class CommitProhibitorGuard:
    """Context manager class that powers prohibit_commit."""

    expected_commit = ...
    def __init__(self, session: Session) -> None: ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *exc_info):  # -> None:
        ...
    def commit(self):  # -> None:
        """
        Commit the session.

        This is the required way to commit when the guard is in scope
        """
        ...

def prohibit_commit(session):  # -> CommitProhibitorGuard:
    """
    Return a context manager that will disallow any commit that isn't done via the context manager.

    The aim of this is to ensure that transaction lifetime is strictly controlled which is especially
    important in the core scheduler loop. Any commit on the session that is _not_ via this context manager
    will result in RuntimeError

    Example usage:

    .. code:: python

        with prohibit_commit(session) as guard:
            # ... do something with session
            guard.commit()

            # This would throw an error
            # session.commit()
    """
    ...

def is_lock_not_available_error(error: OperationalError):  # -> bool:
    """Check if the Error is about not being able to acquire lock."""
    ...

@overload
def tuple_in_condition(
    columns: tuple[ColumnElement, ...], collection: Iterable[Any]
) -> ColumnOperators: ...
@overload
def tuple_in_condition(
    columns: tuple[ColumnElement, ...], collection: Select, *, session: Session
) -> ColumnOperators: ...
def tuple_in_condition(
    columns: tuple[ColumnElement, ...],
    collection: Iterable[Any] | Select,
    *,
    session: Session | None = ...,
) -> ColumnOperators:
    """
    Generate a tuple-in-collection operator to use in ``.where()``.

    For most SQL backends, this generates a simple ``([col, ...]) IN [condition]``
    clause.

    :meta private:
    """
    ...

@overload
def tuple_not_in_condition(
    columns: tuple[ColumnElement, ...], collection: Iterable[Any]
) -> ColumnOperators: ...
@overload
def tuple_not_in_condition(
    columns: tuple[ColumnElement, ...], collection: Select, *, session: Session
) -> ColumnOperators: ...
def tuple_not_in_condition(
    columns: tuple[ColumnElement, ...],
    collection: Iterable[Any] | Select,
    *,
    session: Session | None = ...,
) -> ColumnOperators:
    """
    Generate a tuple-not-in-collection operator to use in ``.where()``.

    This is similar to ``tuple_in_condition`` except generating ``NOT IN``.

    :meta private:
    """
    ...

def get_orm_mapper():  # -> type[Mapper]:
    """Get the correct ORM mapper for the installed SQLAlchemy version."""
    ...

def is_sqlalchemy_v1() -> bool: ...
