"""
This type stub file was generated by pyright.
"""

import logging
from collections.abc import Callable, Collection, Mapping
from typing import TYPE_CHECKING, Any, TypeVar

from airflow.utils.context import OutletEventAccessors

if TYPE_CHECKING: ...
R = TypeVar("R")
DEFAULT_FORMAT_PREFIX = ...
ENV_VAR_FORMAT_PREFIX = ...
AIRFLOW_VAR_NAME_FORMAT_MAPPING = ...

def context_to_airflow_vars(
    context: Mapping[str, Any], in_env_var_format: bool = ...
) -> dict[str, str]:
    """
    Return values used to externally reconstruct relations between dags, dag_runs, tasks and task_instances.

    Given a context, this function provides a dictionary of values that can be used to
    externally reconstruct relations between dags, dag_runs, tasks and task_instances.
    Default to abc.def.ghi format and can be made to ABC_DEF_GHI format if
    in_env_var_format is set to True.

    :param context: The context for the task_instance of interest.
    :param in_env_var_format: If returned vars should be in ABC_DEF_GHI format.
    :return: task_instance context as dict.
    """
    ...

class KeywordParameters:
    """
    Wrapper representing ``**kwargs`` to a callable.

    The actual ``kwargs`` can be obtained by calling either ``unpacking()`` or
    ``serializing()``. They behave almost the same and are only different if
    the containing ``kwargs`` is an Airflow Context object, and the calling
    function uses ``**kwargs`` in the argument list.

    In this particular case, ``unpacking()`` uses ``lazy-object-proxy`` to
    prevent the Context from emitting deprecation warnings too eagerly when it's
    unpacked by ``**``. ``serializing()`` does not do this, and will allow the
    warnings to be emitted eagerly, which is useful when you want to dump the
    content and use it somewhere else without needing ``lazy-object-proxy``.
    """

    def __init__(self, kwargs: Mapping[str, Any], *, wildcard: bool) -> None: ...
    @classmethod
    def determine(
        cls, func: Callable[..., Any], args: Collection[Any], kwargs: Mapping[str, Any]
    ) -> KeywordParameters: ...
    def unpacking(self) -> Mapping[str, Any]:
        """Dump the kwargs mapping to unpack with ``**`` in a function call."""
        ...

    def serializing(self) -> Mapping[str, Any]:
        """Dump the kwargs mapping for serialization purposes."""
        ...

def determine_kwargs(
    func: Callable[..., Any], args: Collection[Any], kwargs: Mapping[str, Any]
) -> Mapping[str, Any]:
    """
    Inspect the signature of a callable to determine which kwargs need to be passed to the callable.

    :param func: The callable that you want to invoke
    :param args: The positional arguments that need to be passed to the callable, so we know how many to skip.
    :param kwargs: The keyword arguments that need to be filtered before passing to the callable.
    :return: A dictionary which contains the keyword arguments that are compatible with the callable.
    """
    ...

def make_kwargs_callable(func: Callable[..., R]) -> Callable[..., R]:
    """
    Create a new callable that only forwards necessary arguments from any provided input.

    Make a new callable that can accept any number of positional or keyword arguments
    but only forwards those required by the given callable func.
    """
    ...

class ExecutionCallableRunner:
    """
    Run an execution callable against a task context and given arguments.

    If the callable is a simple function, this simply calls it with the supplied
    arguments (including the context). If the callable is a generator function,
    the generator is exhausted here, with the yielded values getting fed back
    into the task context automatically for execution.

    :meta private:
    """

    def __init__(
        self,
        func: Callable,
        outlet_events: OutletEventAccessors,
        *,
        logger: logging.Logger | None,
    ) -> None: ...
    def run(self, *args, **kwargs) -> Any: ...
