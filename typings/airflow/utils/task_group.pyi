"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator, Iterator
from typing import TYPE_CHECKING, Any

import methodtools
from airflow.models.abstractoperator import AbstractOperator
from airflow.models.baseoperator import BaseOperator
from airflow.models.dag import DAG
from airflow.models.expandinput import ExpandInput
from airflow.models.operator import Operator
from airflow.models.taskmixin import DAGNode, DependencyMixin
from airflow.serialization.enums import DagAttributeTypes
from airflow.utils.edgemodifier import EdgeModifier
from sqlalchemy.orm import Session

"""A collection of closely related tasks on the same DAG that should be grouped together visually."""
if TYPE_CHECKING: ...
TASKGROUP_ARGS_EXPECTED_TYPES = ...

class TaskGroup(DAGNode):
    """
    A collection of tasks.

    When set_downstream() or set_upstream() are called on the TaskGroup, it is applied across
    all tasks within the group if necessary.

    :param group_id: a unique, meaningful id for the TaskGroup. group_id must not conflict
        with group_id of TaskGroup or task_id of tasks in the DAG. Root TaskGroup has group_id
        set to None.
    :param prefix_group_id: If set to True, child task_id and group_id will be prefixed with
        this TaskGroup's group_id. If set to False, child task_id and group_id are not prefixed.
        Default is True.
    :param parent_group: The parent TaskGroup of this TaskGroup. parent_group is set to None
        for the root TaskGroup.
    :param dag: The DAG that this TaskGroup belongs to.
    :param default_args: A dictionary of default parameters to be used
        as constructor keyword parameters when initialising operators,
        will override default_args defined in the DAG level.
        Note that operators have the same hook, and precede those defined
        here, meaning that if your dict contains `'depends_on_past': True`
        here and `'depends_on_past': False` in the operator's call
        `default_args`, the actual value will be `False`.
    :param tooltip: The tooltip of the TaskGroup node when displayed in the UI
    :param ui_color: The fill color of the TaskGroup node when displayed in the UI
    :param ui_fgcolor: The label color of the TaskGroup node when displayed in the UI
    :param add_suffix_on_collision: If this task group name already exists,
        automatically add `__1` etc suffixes
    """

    used_group_ids: set[str | None]
    def __init__(
        self,
        group_id: str | None,
        prefix_group_id: bool = ...,
        parent_group: TaskGroup | None = ...,
        dag: DAG | None = ...,
        default_args: dict[str, Any] | None = ...,
        tooltip: str = ...,
        ui_color: str = ...,
        ui_fgcolor: str = ...,
        add_suffix_on_collision: bool = ...,
    ) -> None: ...
    @classmethod
    def create_root(cls, dag: DAG) -> TaskGroup:
        """Create a root TaskGroup with no group_id or parent."""
        ...

    @property
    def node_id(self):  # -> str | None:
        ...
    @property
    def is_root(self) -> bool:
        """Returns True if this TaskGroup is the root TaskGroup. Otherwise False."""
        ...

    @property
    def parent_group(self) -> TaskGroup | None: ...
    def __iter__(self):  # -> Generator[Any, Any, None]:
        ...
    def add(self, task: DAGNode) -> DAGNode:
        """
        Add a task to this TaskGroup.

        :meta private:
        """
        ...

    @property
    def group_id(self) -> str | None:
        """group_id of this TaskGroup."""
        ...

    @property
    def label(self) -> str | None:
        """group_id excluding parent's group_id used as the node label in UI."""
        ...

    def update_relative(
        self,
        other: DependencyMixin,
        upstream: bool = ...,
        edge_modifier: EdgeModifier | None = ...,
    ) -> None:
        """
        Override TaskMixin.update_relative.

        Update upstream_group_ids/downstream_group_ids/upstream_task_ids/downstream_task_ids
        accordingly so that we can reduce the number of edges when displaying Graph view.
        """
        ...

    def __enter__(self) -> TaskGroup: ...
    def __exit__(self, _type, _value, _tb):  # -> None:
        ...
    def has_task(self, task: BaseOperator) -> bool:
        """Return True if this TaskGroup or its children TaskGroups contains the given task."""
        ...

    @property
    def roots(self) -> list[BaseOperator]:
        """Required by TaskMixin."""
        ...

    @property
    def leaves(self) -> list[BaseOperator]:
        """Required by TaskMixin."""
        ...

    def get_roots(self) -> Generator[BaseOperator, None, None]:
        """Return a generator of tasks with no upstream dependencies within the TaskGroup."""
        ...

    def get_leaves(self) -> Generator[BaseOperator, None, None]:
        """Return a generator of tasks with no downstream dependencies within the TaskGroup."""
        ...

    def child_id(self, label):  # -> str:
        """Prefix label with group_id if prefix_group_id is True. Otherwise return the label as-is."""
        ...

    @property
    def upstream_join_id(self) -> str:
        """
        Creates a unique ID for upstream dependencies of this TaskGroup.

        If this TaskGroup has immediate upstream TaskGroups or tasks, a proxy node called
        upstream_join_id will be created in Graph view to join the outgoing edges from this
        TaskGroup to reduce the total number of edges needed to be displayed.
        """
        ...

    @property
    def downstream_join_id(self) -> str:
        """
        Creates a unique ID for downstream dependencies of this TaskGroup.

        If this TaskGroup has immediate downstream TaskGroups or tasks, a proxy node called
        downstream_join_id will be created in Graph view to join the outgoing edges from this
        TaskGroup to reduce the total number of edges needed to be displayed.
        """
        ...

    def get_task_group_dict(self) -> dict[str, TaskGroup]:
        """Return a flat dictionary of group_id: TaskGroup."""
        ...

    def get_child_by_label(self, label: str) -> DAGNode:
        """Get a child task/TaskGroup by its label (i.e. task_id/group_id without the group_id prefix)."""
        ...

    def serialize_for_task_group(self) -> tuple[DagAttributeTypes, Any]:
        """Serialize task group; required by DAGNode."""
        ...

    def hierarchical_alphabetical_sort(self):  # -> list[DAGNode]:
        """
        Sort children in hierarchical alphabetical order.

        - groups in alphabetical order first
        - tasks in alphabetical order after them.

        :return: list of tasks in hierarchical alphabetical order
        """
        ...

    def topological_sort(self, _include_subdag_tasks: bool = ...):  # -> list[DAGNode]:
        """
        Sorts children in topographical order, such that a task comes after any of its upstream dependencies.

        :return: list of tasks in topological order
        """
        ...

    def iter_mapped_task_groups(self) -> Iterator[MappedTaskGroup]:
        """
        Return mapped task groups in the hierarchy.

        Groups are returned from the closest to the outmost. If *self* is a
        mapped task group, it is returned first.

        :meta private:
        """
        ...

    def iter_tasks(self) -> Iterator[AbstractOperator]:
        """Return an iterator of the child tasks."""
        ...

class MappedTaskGroup(TaskGroup):
    """
    A mapped task group.

    This doesn't really do anything special, just holds some additional metadata
    for expansion later.

    Don't instantiate this class directly; call *expand* or *expand_kwargs* on
    a ``@task_group`` function instead.
    """

    def __init__(self, *, expand_input: ExpandInput, **kwargs: Any) -> None: ...
    def __iter__(self):  # -> Generator[Any, Any, None]:
        ...
    def iter_mapped_dependencies(self) -> Iterator[Operator]:
        """Upstream dependencies that provide XComs used by this mapped task group."""
        ...

    @methodtools.lru_cache(maxsize=None)
    def get_parse_time_mapped_ti_count(self) -> int:
        """
        Return the Number of instances a task in this group should be mapped to, when a DAG run is created.

        This only considers literal mapped arguments, and would return *None*
        when any non-literal values are used for mapping.

        If this group is inside mapped task groups, all the nested counts are
        multiplied and accounted.

        :meta private:

        :raise NotFullyPopulated: If any non-literal mapped arguments are encountered.
        :return: The total number of mapped instances each task should have.
        """
        ...

    def get_mapped_ti_count(self, run_id: str, *, session: Session) -> int:
        """
        Return the number of instances a task in this group should be mapped to at run time.

        This considers both literal and non-literal mapped arguments, and the
        result is therefore available when all depended tasks have finished. The
        return value should be identical to ``parse_time_mapped_ti_count`` if
        all mapped arguments are literal.

        If this group is inside mapped task groups, all the nested counts are
        multiplied and accounted.

        :meta private:

        :raise NotFullyPopulated: If upstream tasks are not all complete yet.
        :return: Total number of mapped TIs this task should have.
        """
        ...

    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...

class TaskGroupContext:
    """TaskGroup context is used to keep the current TaskGroup when TaskGroup is used as ContextManager."""

    active: bool = ...
    _context_managed_task_group: TaskGroup | None = ...
    _previous_context_managed_task_groups: list[TaskGroup] = ...
    @classmethod
    def push_context_managed_task_group(cls, task_group: TaskGroup):  # -> None:
        """Push a TaskGroup into the list of managed TaskGroups."""
        ...

    @classmethod
    def pop_context_managed_task_group(cls) -> TaskGroup | None:
        """Pops the last TaskGroup from the list of managed TaskGroups and update the current TaskGroup."""
        ...

    @classmethod
    def get_current_task_group(cls, dag: DAG | None) -> TaskGroup | None:
        """Get the current TaskGroup."""
        ...

def task_group_to_dict(task_item_or_group):  # -> dict[str, Any]:
    """Create a nested dict representation of this TaskGroup and its children used to construct the Graph."""
    ...
