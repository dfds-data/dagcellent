"""
This type stub file was generated by pyright.
"""

import functools
import pathlib
from collections import abc, deque
from collections.abc import Callable, Collection, Container, Iterable, Iterator
from datetime import datetime, timedelta
from re import Pattern
from types import ModuleType
from typing import (
    TYPE_CHECKING,
    Any,
    Union,
)

import jinja2
import pendulum
from airflow.api_internal.internal_api_call import internal_api_call
from airflow.datasets import BaseDataset, Dataset, DatasetAlias
from airflow.decorators import TaskDecoratorCollection
from airflow.exceptions import AirflowException
from airflow.models.abstractoperator import TaskStateChangeCallback
from airflow.models.base import Base
from airflow.models.dagbag import DagBag
from airflow.models.dagpickle import DagPickle
from airflow.models.dagrun import DagRun
from airflow.models.operator import Operator
from airflow.models.param import DagParam
from airflow.models.slamiss import SlaMiss
from airflow.models.taskinstance import Context, TaskInstance
from airflow.serialization.pydantic.dag import DagModelPydantic
from airflow.serialization.pydantic.dag_run import DagRunPydantic
from airflow.timetables.base import DagRunInfo, DataInterval, Timetable
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.utils.session import provide_session
from airflow.utils.state import DagRunState, TaskInstanceState
from airflow.utils.task_group import TaskGroup
from airflow.utils.types import ArgNotSet, DagRunType, EdgeInfoType
from dateutil.relativedelta import relativedelta
from pendulum.tz.timezone import FixedTimezone, Timezone
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm.query import Query
from sqlalchemy.orm.session import Session

if TYPE_CHECKING: ...
log = ...
DEFAULT_VIEW_PRESETS = ...
ORIENTATION_PRESETS = ...
TAG_MAX_LEN = ...
DagStateChangeCallback = Callable[[Context], None]
ScheduleInterval = Union[None, str, timedelta, relativedelta]
ScheduleIntervalArg = Union[ArgNotSet, ScheduleInterval]
ScheduleArg = Union[
    ArgNotSet,
    ScheduleInterval,
    Timetable,
    BaseDataset,
    Collection[Union["Dataset", "DatasetAlias"]],
]
SLAMissCallback = Callable[["DAG", str, str, list["SlaMiss"], list[TaskInstance]], None]
DEFAULT_SCHEDULE_INTERVAL = ...

class InconsistentDataInterval(AirflowException):
    """
    Exception raised when a model populates data interval fields incorrectly.

    The data interval fields should either both be None (for runs scheduled
    prior to AIP-39), or both be datetime (for runs scheduled after AIP-39 is
    implemented). This is raised if exactly one of the fields is None.
    """

    _template = ...
    def __init__(
        self, instance: Any, start_field_name: str, end_field_name: str
    ) -> None: ...
    def __str__(self) -> str: ...

def create_timetable(
    interval: ScheduleIntervalArg, timezone: Timezone | FixedTimezone
) -> Timetable:
    """Create a Timetable instance from a ``schedule_interval`` argument."""
    ...

def get_last_dagrun(dag_id, session, include_externally_triggered=...):
    """
    Return the last dag run for a dag, None if there was none.

    Last dag run can be any type of run e.g. scheduled or backfilled.
    Overridden DagRuns are ignored.
    """
    ...

def get_dataset_triggered_next_run_info(
    dag_ids: list[str], *, session: Session
) -> dict[str, dict[str, int | str]]:
    """
    Get next run info for a list of dag_ids.

    Given a list of dag_ids, get string representing how close any that are dataset triggered are
    their next run, e.g. "1 of 2 datasets updated".
    """
    ...

DAG_ARGS_EXPECTED_TYPES = ...

@functools.total_ordering
class DAG(LoggingMixin):
    """
    A dag (directed acyclic graph) is a collection of tasks with directional dependencies.

    A dag also has a schedule, a start date and an end date (optional).  For each schedule,
    (say daily or hourly), the DAG needs to run each individual tasks as their dependencies
    are met. Certain tasks have the property of depending on their own past, meaning that
    they can't run until their previous schedule (and upstream tasks) are completed.

    DAGs essentially act as namespaces for tasks. A task_id can only be
    added once to a DAG.

    Note that if you plan to use time zones all the dates provided should be pendulum
    dates. See :ref:`timezone_aware_dags`.

    .. versionadded:: 2.4
        The *schedule* argument to specify either time-based scheduling logic
        (timetable), or dataset-driven triggers.

    .. deprecated:: 2.4
        The arguments *schedule_interval* and *timetable*. Their functionalities
        are merged into the new *schedule* argument.

    :param dag_id: The id of the DAG; must consist exclusively of alphanumeric
        characters, dashes, dots and underscores (all ASCII)
    :param description: The description for the DAG to e.g. be shown on the webserver
    :param schedule: Defines the rules according to which DAG runs are scheduled. Can
        accept cron string, timedelta object, Timetable, or list of Dataset objects.
        If this is not provided, the DAG will be set to the default
        schedule ``timedelta(days=1)``. See also :doc:`/howto/timetable`.
    :param start_date: The timestamp from which the scheduler will
        attempt to backfill
    :param end_date: A date beyond which your DAG won't run, leave to None
        for open-ended scheduling
    :param template_searchpath: This list of folders (non-relative)
        defines where jinja will look for your templates. Order matters.
        Note that jinja/airflow includes the path of your DAG file by
        default
    :param template_undefined: Template undefined type.
    :param user_defined_macros: a dictionary of macros that will be exposed
        in your jinja templates. For example, passing ``dict(foo='bar')``
        to this argument allows you to ``{{ foo }}`` in all jinja
        templates related to this DAG. Note that you can pass any
        type of object here.
    :param user_defined_filters: a dictionary of filters that will be exposed
        in your jinja templates. For example, passing
        ``dict(hello=lambda name: 'Hello %s' % name)`` to this argument allows
        you to ``{{ 'world' | hello }}`` in all jinja templates related to
        this DAG.
    :param default_args: A dictionary of default parameters to be used
        as constructor keyword parameters when initialising operators.
        Note that operators have the same hook, and precede those defined
        here, meaning that if your dict contains `'depends_on_past': True`
        here and `'depends_on_past': False` in the operator's call
        `default_args`, the actual value will be `False`.
    :param params: a dictionary of DAG level parameters that are made
        accessible in templates, namespaced under `params`. These
        params can be overridden at the task level.
    :param max_active_tasks: the number of task instances allowed to run
        concurrently
    :param max_active_runs: maximum number of active DAG runs, beyond this
        number of DAG runs in a running state, the scheduler won't create
        new active DAG runs
    :param max_consecutive_failed_dag_runs: (experimental) maximum number of consecutive failed DAG runs,
        beyond this the scheduler will disable the DAG
    :param dagrun_timeout: specify how long a DagRun should be up before
        timing out / failing, so that new DagRuns can be created.
    :param sla_miss_callback: specify a function or list of functions to call when reporting SLA
        timeouts. See :ref:`sla_miss_callback<concepts:sla_miss_callback>` for
        more information about the function signature and parameters that are
        passed to the callback.
    :param default_view: Specify DAG default view (grid, graph, duration,
                                                   gantt, landing_times), default grid
    :param orientation: Specify DAG orientation in graph view (LR, TB, RL, BT), default LR
    :param catchup: Perform scheduler catchup (or only run latest)? Defaults to True
    :param on_failure_callback: A function or list of functions to be called when a DagRun of this dag fails.
        A context dictionary is passed as a single parameter to this function.
    :param on_success_callback: Much like the ``on_failure_callback`` except
        that it is executed when the dag succeeds.
    :param access_control: Specify optional DAG-level actions, e.g.,
        "{'role1': {'can_read'}, 'role2': {'can_read', 'can_edit', 'can_delete'}}"
        or it can specify the resource name if there is a DAGs Run resource, e.g.,
        "{'role1': {'DAG Runs': {'can_create'}}, 'role2': {'DAGs': {'can_read', 'can_edit', 'can_delete'}}"
    :param is_paused_upon_creation: Specifies if the dag is paused when created for the first time.
        If the dag exists already, this flag will be ignored. If this optional parameter
        is not specified, the global config setting will be used.
    :param jinja_environment_kwargs: additional configuration options to be passed to Jinja
        ``Environment`` for template rendering

        **Example**: to avoid Jinja from removing a trailing newline from template strings ::

            DAG(
                dag_id="my-dag",
                jinja_environment_kwargs={
                    "keep_trailing_newline": True,
                    # some other jinja2 Environment options here
                },
            )

        **See**: `Jinja Environment documentation
        <https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Environment>`_

    :param render_template_as_native_obj: If True, uses a Jinja ``NativeEnvironment``
        to render templates as native Python types. If False, a Jinja
        ``Environment`` is used to render templates as string values.
    :param tags: List of tags to help filtering DAGs in the UI.
    :param owner_links: Dict of owners and their links, that will be clickable on the DAGs view UI.
        Can be used as an HTTP link (for example the link to your Slack channel), or a mailto link.
        e.g: {"dag_owner": "https://airflow.apache.org/"}
    :param auto_register: Automatically register this DAG when it is used in a ``with`` block
    :param fail_stop: Fails currently running tasks when task in DAG fails.
        **Warning**: A fail stop dag can only have tasks with the default trigger rule ("all_success").
        An exception will be thrown if any task in a fail stop dag has a non default trigger rule.
    :param dag_display_name: The display name of the DAG which appears on the UI.
    """

    _comps = ...
    __serialized_fields: frozenset[str] | None = ...
    fileloc: str
    parent_dag: DAG | None = ...
    def __init__(
        self,
        dag_id: str,
        description: str | None = ...,
        schedule: ScheduleArg = ...,
        schedule_interval: ScheduleIntervalArg = ...,
        timetable: Timetable | None = ...,
        start_date: datetime | None = ...,
        end_date: datetime | None = ...,
        full_filepath: str | None = ...,
        template_searchpath: str | Iterable[str] | None = ...,
        template_undefined: type[jinja2.StrictUndefined] = ...,
        user_defined_macros: dict | None = ...,
        user_defined_filters: dict | None = ...,
        default_args: dict | None = ...,
        concurrency: int | None = ...,
        max_active_tasks: int = ...,
        max_active_runs: int = ...,
        max_consecutive_failed_dag_runs: int = ...,
        dagrun_timeout: timedelta | None = ...,
        sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = ...,
        default_view: str = ...,
        orientation: str = ...,
        catchup: bool = ...,
        on_success_callback: None
        | DagStateChangeCallback
        | list[DagStateChangeCallback] = ...,
        on_failure_callback: None
        | DagStateChangeCallback
        | list[DagStateChangeCallback] = ...,
        doc_md: str | None = ...,
        params: abc.MutableMapping | None = ...,
        access_control: dict[str, dict[str, Collection[str]]]
        | dict[str, Collection[str]]
        | None = ...,
        is_paused_upon_creation: bool | None = ...,
        jinja_environment_kwargs: dict | None = ...,
        render_template_as_native_obj: bool = ...,
        tags: list[str] | None = ...,
        owner_links: dict[str, str] | None = ...,
        auto_register: bool = ...,
        fail_stop: bool = ...,
        dag_display_name: str | None = ...,
    ) -> None: ...
    def get_doc_md(self, doc_md: str | None) -> str | None: ...
    def validate(self):  # -> None:
        """
        Validate the DAG has a coherent setup.

        This is called by the DAG bag before bagging the DAG.
        """
        ...

    def validate_executor_field(self):  # -> None:
        ...
    def validate_setup_teardown(self):  # -> None:
        """
        Validate that setup and teardown tasks are configured properly.

        :meta private:
        """
        ...

    def __repr__(self):  # -> str:
        ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, _type, _value, _tb):  # -> None:
        ...
    def date_range(
        self,
        start_date: pendulum.DateTime,
        num: int | None = ...,
        end_date: datetime | None = ...,
    ) -> list[datetime]: ...
    def is_fixed_time_schedule(self):  # -> Any | Literal[True]:
        """
        Figures out if the schedule has a fixed time (e.g. 3 AM every day).

        Detection is done by "peeking" the next two cron trigger time; if the
        two times have the same minute and hour value, the schedule is fixed,
        and we *don't* need to perform the DST fix.

        This assumes DST happens on whole minute changes (e.g. 12:59 -> 12:00).

        Do not try to understand what this actually means. It is old logic that
        should not be used anywhere.
        """
        ...

    def following_schedule(self, dttm):  # -> DateTime | None:
        """
        Calculate the following schedule for this dag in UTC.

        :param dttm: utc datetime
        :return: utc datetime
        """
        ...

    def previous_schedule(self, dttm):  # -> DateTime | None:
        ...
    def get_next_data_interval(self, dag_model: DagModel) -> DataInterval | None:
        """
        Get the data interval of the next scheduled run.

        For compatibility, this method infers the data interval from the DAG's
        schedule if the run does not have an explicit one set, which is possible
        for runs created prior to AIP-39.

        This function is private to Airflow core and should not be depended on as a
        part of the Python API.

        :meta private:
        """
        ...

    def get_run_data_interval(self, run: DagRun | DagRunPydantic) -> DataInterval:
        """
        Get the data interval of this run.

        For compatibility, this method infers the data interval from the DAG's
        schedule if the run does not have an explicit one set, which is possible for
        runs created prior to AIP-39.

        This function is private to Airflow core and should not be depended on as a
        part of the Python API.

        :meta private:
        """
        ...

    def infer_automated_data_interval(self, logical_date: datetime) -> DataInterval:
        """
        Infer a data interval for a run against this DAG.

        This method is used to bridge runs created prior to AIP-39
        implementation, which do not have an explicit data interval. Therefore,
        this method only considers ``schedule_interval`` values valid prior to
        Airflow 2.2.

        DO NOT call this method if there is a known data interval.

        :meta private:
        """
        ...

    def next_dagrun_info(
        self,
        last_automated_dagrun: None | datetime | DataInterval,
        *,
        restricted: bool = ...,
    ) -> DagRunInfo | None:
        """
        Get information about the next DagRun of this dag after ``date_last_automated_dagrun``.

        This calculates what time interval the next DagRun should operate on
        (its execution date) and when it can be scheduled, according to the
        dag's timetable, start_date, end_date, etc. This doesn't check max
        active run or any other "max_active_tasks" type limits, but only
        performs calculations based on the various date and interval fields of
        this dag and its tasks.

        :param last_automated_dagrun: The ``max(execution_date)`` of
            existing "automated" DagRuns for this dag (scheduled or backfill,
            but not manual).
        :param restricted: If set to *False* (default is *True*), ignore
            ``start_date``, ``end_date``, and ``catchup`` specified on the DAG
            or tasks.
        :return: DagRunInfo of the next dagrun, or None if a dagrun is not
            going to be scheduled.
        """
        ...

    def next_dagrun_after_date(
        self, date_last_automated_dagrun: pendulum.DateTime | None
    ):  # -> DateTime | None:
        ...
    def iter_dagrun_infos_between(
        self,
        earliest: pendulum.DateTime | None,
        latest: pendulum.DateTime,
        *,
        align: bool = ...,
    ) -> Iterable[DagRunInfo]:
        """
        Yield DagRunInfo using this DAG's timetable between given interval.

        DagRunInfo instances yielded if their ``logical_date`` is not earlier
        than ``earliest``, nor later than ``latest``. The instances are ordered
        by their ``logical_date`` from earliest to latest.

        If ``align`` is ``False``, the first run will happen immediately on
        ``earliest``, even if it does not fall on the logical timetable schedule.
        The default is ``True``, but subdags will ignore this value and always
        behave as if this is set to ``False`` for backward compatibility.

        Example: A DAG is scheduled to run every midnight (``0 0 * * *``). If
        ``earliest`` is ``2021-06-03 23:00:00``, the first DagRunInfo would be
        ``2021-06-03 23:00:00`` if ``align=False``, and ``2021-06-04 00:00:00``
        if ``align=True``.
        """
        ...

    def get_run_dates(self, start_date, end_date=...) -> list:
        """
        Return a list of dates between the interval received as parameter using this dag's schedule interval.

        Returned dates can be used for execution dates.

        :param start_date: The start date of the interval.
        :param end_date: The end date of the interval. Defaults to ``timezone.utcnow()``.
        :return: A list of dates within the interval following the dag's schedule.
        """
        ...

    def normalize_schedule(self, dttm):  # -> DateTime:
        ...
    @provide_session
    def get_last_dagrun(self, session=..., include_externally_triggered=...): ...
    @provide_session
    def has_dag_runs(self, session=..., include_externally_triggered=...) -> bool: ...
    @property
    def dag_id(self) -> str: ...
    @dag_id.setter
    def dag_id(self, value: str) -> None: ...
    @property
    def is_subdag(self) -> bool: ...
    @property
    def full_filepath(self) -> str:
        """
        Full file path to the DAG.

        :meta private:
        """
        ...

    @full_filepath.setter
    def full_filepath(self, value) -> None: ...
    @property
    def concurrency(self) -> int: ...
    @concurrency.setter
    def concurrency(self, value: int):  # -> None:
        ...
    @property
    def max_active_tasks(self) -> int: ...
    @max_active_tasks.setter
    def max_active_tasks(self, value: int):  # -> None:
        ...
    @property
    def access_control(self):  # -> dict[Any, Any] | None:
        ...
    @access_control.setter
    def access_control(self, value):  # -> None:
        ...
    @property
    def dag_display_name(self) -> str: ...
    @property
    def description(self) -> str | None: ...
    @property
    def default_view(self) -> str: ...
    @property
    def pickle_id(self) -> int | None: ...
    @pickle_id.setter
    def pickle_id(self, value: int) -> None: ...
    def param(self, name: str, default: Any = ...) -> DagParam:
        """
        Return a DagParam object for current dag.

        :param name: dag parameter name.
        :param default: fallback value for dag parameter.
        :return: DagParam instance for specified name and current dag.
        """
        ...

    @property
    def tasks(self) -> list[Operator]: ...
    @tasks.setter
    def tasks(self, val): ...
    @property
    def task_ids(self) -> list[str]: ...
    @property
    def teardowns(self) -> list[Operator]: ...
    @property
    def tasks_upstream_of_teardowns(self) -> list[Operator]: ...
    @property
    def task_group(self) -> TaskGroup: ...
    @property
    def filepath(self) -> str:
        """
        Relative file path to the DAG.

        :meta private:
        """
        ...

    @property
    def relative_fileloc(self) -> pathlib.Path:
        """File location of the importable dag 'file' relative to the configured DAGs folder."""
        ...

    @property
    def folder(self) -> str:
        """Folder location of where the DAG object is instantiated."""
        ...

    @property
    def owner(self) -> str:
        """
        Return list of all owners found in DAG tasks.

        :return: Comma separated list of owners in DAG tasks
        """
        ...

    @property
    def allow_future_exec_dates(self) -> bool: ...
    @provide_session
    def get_concurrency_reached(self, session=...) -> bool:
        """Return a boolean indicating whether the max_active_tasks limit for this DAG has been reached."""
        ...

    @property
    def concurrency_reached(self):  # -> bool:
        """Use `airflow.models.DAG.get_concurrency_reached`, this attribute is deprecated."""
        ...

    @provide_session
    def get_is_active(self, session=...) -> None:
        """Return a boolean indicating whether this DAG is active."""
        ...

    @provide_session
    def get_is_paused(self, session=...) -> None:
        """Return a boolean indicating whether this DAG is paused."""
        ...

    @property
    def is_paused(self):  # -> None:
        """Use `airflow.models.DAG.get_is_paused`, this attribute is deprecated."""
        ...

    @property
    def normalized_schedule_interval(self) -> ScheduleInterval: ...
    @staticmethod
    @internal_api_call
    @provide_session
    def fetch_callback(
        dag: DAG,
        dag_run_id: str,
        success: bool = ...,
        reason: str | None = ...,
        *,
        session: Session = ...,
    ) -> tuple[list[TaskStateChangeCallback], Context] | None:
        """
        Fetch the appropriate callbacks depending on the value of success.

        This method gets the context of a single TaskInstance part of this DagRun and returns it along
        the list of callbacks.

        :param dag: DAG object
        :param dag_run_id: The DAG run ID
        :param success: Flag to specify if failure or success callback should be called
        :param reason: Completion reason
        :param session: Database session
        """
        ...

    @provide_session
    def handle_callback(
        self, dagrun: DagRun, success=..., reason=..., session=...
    ):  # -> None:
        """
        Triggers on_failure_callback or on_success_callback as appropriate.

        This method gets the context of a single TaskInstance part of this DagRun
        and passes that to the callable along with a 'reason', primarily to
        differentiate DagRun failures.

        .. note: The logs end up in
            ``$AIRFLOW_HOME/logs/scheduler/latest/PROJECT/DAG_FILE.py.log``

        :param dagrun: DagRun object
        :param success: Flag to specify if failure or success callback should be called
        :param reason: Completion reason
        :param session: Database session
        """
        ...

    @classmethod
    def execute_callback(
        cls, callbacks: list[Callable] | None, context: Context | None, dag_id: str
    ):  # -> None:
        """
        Triggers the callbacks with the given context.

        :param callbacks: List of callbacks to call
        :param context: Context to pass to all callbacks
        :param dag_id: The dag_id of the DAG to find.
        """
        ...

    def get_active_runs(self):  # -> list[Any]:
        """
        Return a list of dag run execution dates currently running.

        :return: List of execution dates
        """
        ...

    @provide_session
    def get_num_active_runs(self, external_trigger=..., only_running=..., session=...):
        """
        Return the number of active "running" dag runs.

        :param external_trigger: True for externally triggered active dag runs
        :param session:
        :return: number greater than 0 for active dag runs
        """
        ...

    @staticmethod
    @internal_api_call
    @provide_session
    def fetch_dagrun(
        dag_id: str,
        execution_date: datetime | None = ...,
        run_id: str | None = ...,
        session: Session = ...,
    ) -> DagRun | DagRunPydantic:
        """
        Return the dag run for a given execution date or run_id if it exists, otherwise none.

        :param dag_id: The dag_id of the DAG to find.
        :param execution_date: The execution date of the DagRun to find.
        :param run_id: The run_id of the DagRun to find.
        :param session:
        :return: The DagRun if found, otherwise None.
        """
        ...

    @provide_session
    def get_dagrun(
        self,
        execution_date: datetime | None = ...,
        run_id: str | None = ...,
        session: Session = ...,
    ) -> DagRun | DagRunPydantic: ...
    @provide_session
    def get_dagruns_between(self, start_date, end_date, session=...):
        """
        Return the list of dag runs between start_date (inclusive) and end_date (inclusive).

        :param start_date: The starting execution date of the DagRun to find.
        :param end_date: The ending execution date of the DagRun to find.
        :param session:
        :return: The list of DagRuns found.
        """
        ...

    @provide_session
    def get_latest_execution_date(
        self, session: Session = ...
    ) -> pendulum.DateTime | None:
        """Return the latest date for which at least one dag run exists."""
        ...

    @property
    def latest_execution_date(self):  # -> DateTime | None:
        """Use `airflow.models.DAG.get_latest_execution_date`, this attribute is deprecated."""
        ...

    @property
    def subdags(self):  # -> list[Any]:
        """Return a list of the subdag objects associated to this DAG."""
        ...

    def resolve_template_files(self):  # -> None:
        ...
    def get_template_env(self, *, force_sandboxed: bool = ...) -> jinja2.Environment:
        """Build a Jinja2 environment."""
        ...

    def set_dependency(self, upstream_task_id, downstream_task_id):  # -> None:
        """Set dependency between two tasks that already have been added to the DAG using add_task()."""
        ...

    @provide_session
    def get_task_instances_before(
        self, base_date: datetime, num: int, *, session: Session = ...
    ) -> list[TaskInstance]:
        """
        Get ``num`` task instances before (including) ``base_date``.

        The returned list may contain exactly ``num`` task instances
        corresponding to any DagRunType. It can have less if there are
        less than ``num`` scheduled DAG runs before ``base_date``.
        """
        ...

    @provide_session
    def get_task_instances(
        self,
        start_date: datetime | None = ...,
        end_date: datetime | None = ...,
        state: list[TaskInstanceState] | None = ...,
        session: Session = ...,
    ) -> list[TaskInstance]: ...
    @provide_session
    def set_task_instance_state(
        self,
        *,
        task_id: str,
        map_indexes: Collection[int] | None = ...,
        execution_date: datetime | None = ...,
        run_id: str | None = ...,
        state: TaskInstanceState,
        upstream: bool = ...,
        downstream: bool = ...,
        future: bool = ...,
        past: bool = ...,
        commit: bool = ...,
        session=...,
    ) -> list[TaskInstance]:
        """
        Set the state of a TaskInstance and clear downstream tasks in failed or upstream_failed state.

        :param task_id: Task ID of the TaskInstance
        :param map_indexes: Only set TaskInstance if its map_index matches.
            If None (default), all mapped TaskInstances of the task are set.
        :param execution_date: Execution date of the TaskInstance
        :param run_id: The run_id of the TaskInstance
        :param state: State to set the TaskInstance to
        :param upstream: Include all upstream tasks of the given task_id
        :param downstream: Include all downstream tasks of the given task_id
        :param future: Include all future TaskInstances of the given task_id
        :param commit: Commit changes
        :param past: Include all past TaskInstances of the given task_id
        """
        ...

    @provide_session
    def set_task_group_state(
        self,
        *,
        group_id: str,
        execution_date: datetime | None = ...,
        run_id: str | None = ...,
        state: TaskInstanceState,
        upstream: bool = ...,
        downstream: bool = ...,
        future: bool = ...,
        past: bool = ...,
        commit: bool = ...,
        session: Session = ...,
    ) -> list[TaskInstance]:
        """
        Set TaskGroup to the given state and clear downstream tasks in failed or upstream_failed state.

        :param group_id: The group_id of the TaskGroup
        :param execution_date: Execution date of the TaskInstance
        :param run_id: The run_id of the TaskInstance
        :param state: State to set the TaskInstance to
        :param upstream: Include all upstream tasks of the given task_id
        :param downstream: Include all downstream tasks of the given task_id
        :param future: Include all future TaskInstances of the given task_id
        :param commit: Commit changes
        :param past: Include all past TaskInstances of the given task_id
        :param session: new session
        """
        ...

    @property
    def roots(self) -> list[Operator]:
        """Return nodes with no parents. These are first to execute and are called roots or root nodes."""
        ...

    @property
    def leaves(self) -> list[Operator]:
        """Return nodes with no children. These are last to execute and are called leaves or leaf nodes."""
        ...

    def topological_sort(self, include_subdag_tasks: bool = ...):  # -> tuple[Any, ...]:
        """
        Sorts tasks in topographical order, such that a task comes after any of its upstream dependencies.

        Deprecated in place of ``task_group.topological_sort``
        """
        ...

    @provide_session
    def set_dag_runs_state(
        self,
        state: DagRunState = ...,
        session: Session = ...,
        start_date: datetime | None = ...,
        end_date: datetime | None = ...,
        dag_ids: list[str] | None = ...,
    ) -> None: ...
    @provide_session
    def clear(
        self,
        task_ids: Collection[str | tuple[str, int]] | None = ...,
        start_date: datetime | None = ...,
        end_date: datetime | None = ...,
        only_failed: bool = ...,
        only_running: bool = ...,
        confirm_prompt: bool = ...,
        include_subdags: bool = ...,
        include_parentdag: bool = ...,
        dag_run_state: DagRunState = ...,
        dry_run: bool = ...,
        session: Session = ...,
        get_tis: bool = ...,
        recursion_depth: int = ...,
        max_recursion_depth: int | None = ...,
        dag_bag: DagBag | None = ...,
        exclude_task_ids: frozenset[str] | frozenset[tuple[str, int]] | None = ...,
    ) -> int | Iterable[TaskInstance]:
        """
        Clear a set of task instances associated with the current dag for a specified date range.

        :param task_ids: List of task ids or (``task_id``, ``map_index``) tuples to clear
        :param start_date: The minimum execution_date to clear
        :param end_date: The maximum execution_date to clear
        :param only_failed: Only clear failed tasks
        :param only_running: Only clear running tasks.
        :param confirm_prompt: Ask for confirmation
        :param include_subdags: Clear tasks in subdags and clear external tasks
            indicated by ExternalTaskMarker
        :param include_parentdag: Clear tasks in the parent dag of the subdag.
        :param dag_run_state: state to set DagRun to. If set to False, dagrun state will not
            be changed.
        :param dry_run: Find the tasks to clear but don't clear them.
        :param session: The sqlalchemy session to use
        :param dag_bag: The DagBag used to find the dags subdags (Optional)
        :param exclude_task_ids: A set of ``task_id`` or (``task_id``, ``map_index``)
            tuples that should not be cleared
        """
        ...

    @classmethod
    def clear_dags(
        cls,
        dags,
        start_date=...,
        end_date=...,
        only_failed=...,
        only_running=...,
        confirm_prompt=...,
        include_subdags=...,
        include_parentdag=...,
        dag_run_state=...,
        dry_run=...,
    ):  # -> list[Any] | int:
        ...
    def __deepcopy__(self, memo):  # -> Self:
        ...
    def sub_dag(self, *args, **kwargs):  # -> Self:
        """Use `airflow.models.DAG.partial_subset`, this method is deprecated."""
        ...

    def partial_subset(
        self,
        task_ids_or_regex: str | Pattern | Iterable[str],
        include_downstream=...,
        include_upstream=...,
        include_direct_upstream=...,
    ):  # -> Self:
        """
        Return a subset of the current dag based on regex matching one or more tasks.

        Returns a subset of the current dag as a deep copy of the current dag
        based on a regex that should match one or many tasks, and includes
        upstream and downstream neighbours based on the flag passed.

        :param task_ids_or_regex: Either a list of task_ids, or a regex to
            match against task ids (as a string, or compiled regex pattern).
        :param include_downstream: Include all downstream tasks of matched
            tasks, in addition to matched tasks.
        :param include_upstream: Include all upstream tasks of matched tasks,
            in addition to matched tasks.
        :param include_direct_upstream: Include all tasks directly upstream of matched
            and downstream (if include_downstream = True) tasks
        """
        ...

    def has_task(self, task_id: str):  # -> bool:
        ...
    def has_task_group(self, task_group_id: str) -> bool: ...
    @functools.cached_property
    def task_group_dict(self):  # -> dict[str, TaskGroup]:
        ...
    def get_task(self, task_id: str, include_subdags: bool = ...) -> Operator: ...
    def pickle_info(self):  # -> dict[Any, Any]:
        ...
    @provide_session
    def pickle(self, session=...) -> DagPickle: ...
    def tree_view(self) -> None:
        """Print an ASCII tree representation of the DAG."""
        ...

    def get_tree_view(self) -> str:
        """Return an ASCII tree representation of the DAG."""
        ...

    @property
    def task(self) -> TaskDecoratorCollection: ...
    def add_task(self, task: Operator) -> None:
        """
        Add a task to the DAG.

        :param task: the task you want to add
        """
        ...

    def add_tasks(self, tasks: Iterable[Operator]) -> None:
        """
        Add a list of tasks to the DAG.

        :param tasks: a lit of tasks you want to add
        """
        ...

    def run(
        self,
        start_date=...,
        end_date=...,
        mark_success=...,
        local=...,
        donot_pickle=...,
        ignore_task_deps=...,
        ignore_first_depends_on_past=...,
        pool=...,
        delay_on_limit_secs=...,
        verbose=...,
        conf=...,
        rerun_failed_tasks=...,
        run_backwards=...,
        run_at_least_once=...,
        continue_on_failures=...,
        disable_retry=...,
    ):  # -> None:
        """
        Run the DAG.

        :param start_date: the start date of the range to run
        :param end_date: the end date of the range to run
        :param mark_success: True to mark jobs as succeeded without running them
        :param local: True to run the tasks using the LocalExecutor
        :param executor: The executor instance to run the tasks
        :param donot_pickle: True to avoid pickling DAG object and send to workers
        :param ignore_task_deps: True to skip upstream tasks
        :param ignore_first_depends_on_past: True to ignore depends_on_past
            dependencies for the first set of tasks only
        :param pool: Resource pool to use
        :param delay_on_limit_secs: Time in seconds to wait before next attempt to run
            dag run when max_active_runs limit has been reached
        :param verbose: Make logging output more verbose
        :param conf: user defined dictionary passed from CLI
        :param rerun_failed_tasks:
        :param run_backwards:
        :param run_at_least_once: If true, always run the DAG at least once even
            if no logical run exists within the time range.
        """
        ...

    def cli(self):  # -> None:
        """Exposes a CLI specific to this DAG."""
        ...

    @provide_session
    def test(
        self,
        execution_date: datetime | None = ...,
        run_conf: dict[str, Any] | None = ...,
        conn_file_path: str | None = ...,
        variable_file_path: str | None = ...,
        use_executor: bool = ...,
        mark_success_pattern: Pattern | str | None = ...,
        session: Session = ...,
    ) -> DagRun:
        """
        Execute one single DagRun for a given DAG and execution date.

        :param execution_date: execution date for the DAG run
        :param run_conf: configuration to pass to newly created dagrun
        :param conn_file_path: file path to a connection file in either yaml or json
        :param variable_file_path: file path to a variable file in either yaml or json
        :param use_executor: if set, uses an executor to test the DAG
        :param mark_success_pattern: regex of task_ids to mark as success instead of running
        :param session: database connection (optional)
        """
        ...

    @provide_session
    def create_dagrun(
        self,
        state: DagRunState,
        execution_date: datetime | None = ...,
        run_id: str | None = ...,
        start_date: datetime | None = ...,
        external_trigger: bool | None = ...,
        conf: dict | None = ...,
        run_type: DagRunType | None = ...,
        session: Session = ...,
        dag_hash: str | None = ...,
        creating_job_id: int | None = ...,
        data_interval: tuple[datetime, datetime] | None = ...,
    ):  # -> DagRun:
        """
        Create a dag run from this dag including the tasks associated with this dag.

        Returns the dag run.

        :param run_id: defines the run id for this dag run
        :param run_type: type of DagRun
        :param execution_date: the execution date of this dag run
        :param state: the state of the dag run
        :param start_date: the date this dag run should be evaluated
        :param external_trigger: whether this dag run is externally triggered
        :param conf: Dict containing configuration/parameters to pass to the DAG
        :param creating_job_id: id of the job creating this DagRun
        :param session: database session
        :param dag_hash: Hash of Serialized DAG
        :param data_interval: Data interval of the DagRun
        """
        ...

    @classmethod
    @provide_session
    def bulk_sync_to_db(cls, dags: Collection[DAG], session=...):  # -> None:
        """Use `airflow.models.DAG.bulk_write_to_db`, this method is deprecated."""
        ...

    @classmethod
    @provide_session
    def bulk_write_to_db(
        cls, dags: Collection[DAG], processor_subdir: str | None = ..., session=...
    ):  # -> None:
        """
        Ensure the DagModel rows for the given dags are up-to-date in the dag table in the DB.

        Note that this method can be called for both DAGs and SubDAGs. A SubDag is actually a SubDagOperator.

        :param dags: the DAG objects to save to the DB
        :return: None
        """
        ...

    @provide_session
    def sync_to_db(self, processor_subdir: str | None = ..., session=...):  # -> None:
        """
        Save attributes about this DAG to the DB.

        Note that this method can be called for both DAGs and SubDAGs. A SubDag is actually a SubDagOperator.

        :return: None
        """
        ...

    def get_default_view(self):  # -> str:
        """Allow backward compatible jinja2 templates."""
        ...

    @staticmethod
    @provide_session
    def deactivate_unknown_dags(active_dag_ids, session=...):  # -> None:
        """
        Given a list of known DAGs, deactivate any other DAGs that are marked as active in the ORM.

        :param active_dag_ids: list of DAG IDs that are active
        :return: None
        """
        ...

    @staticmethod
    @provide_session
    def deactivate_stale_dags(expiration_date, session=...):  # -> None:
        """
        Deactivate any DAGs that were last touched by the scheduler before the expiration date.

        These DAGs were likely deleted.

        :param expiration_date: set inactive DAGs that were touched before this time
        :return: None
        """
        ...

    @staticmethod
    @provide_session
    def get_num_task_instances(
        dag_id, run_id=..., task_ids=..., states=..., session=...
    ) -> int:
        """
        Return the number of task instances in the given DAG.

        :param session: ORM session
        :param dag_id: ID of the DAG to get the task concurrency of
        :param run_id: ID of the DAG run to get the task concurrency of
        :param task_ids: A list of valid task IDs for the given DAG
        :param states: A list of states to filter by if supplied
        :return: The number of running tasks
        """
        ...

    @classmethod
    def get_serialized_fields(cls):  # -> frozenset[str]:
        """Stringified DAGs and operators contain exactly these fields."""
        ...

    def get_edge_info(
        self, upstream_task_id: str, downstream_task_id: str
    ) -> EdgeInfoType:
        """Return edge information for the given pair of tasks or an empty edge if there is no information."""
        ...

    def set_edge_info(
        self, upstream_task_id: str, downstream_task_id: str, info: EdgeInfoType
    ):  # -> None:
        """
        Set the given edge information on the DAG.

        Note that this will overwrite, rather than merge with, existing info.
        """
        ...

    def validate_schedule_and_params(self):  # -> None:
        """
        Validate Param values when the DAG has schedule defined.

        Raise exception if there are any Params which can not be resolved by their schema definition.
        """
        ...

    def iter_invalid_owner_links(self) -> Iterator[tuple[str, str]]:
        """
        Parse a given link, and verifies if it's a valid URL, or a 'mailto' link.

        Returns an iterator of invalid (owner, link) pairs.
        """
        ...

class DagTag(Base):
    """A tag name per dag, to allow quick filtering in the DAG view."""

    __tablename__ = ...
    name = ...
    dag_id = ...
    __table_args__ = ...
    def __repr__(self): ...

class DagOwnerAttributes(Base):
    """
    Table defining different owner attributes.

    For example, a link for an owner that will be passed as a hyperlink to the "DAGs" view.
    """

    __tablename__ = ...
    dag_id = ...
    owner = ...
    link = ...
    def __repr__(self):  # -> str:
        ...
    @classmethod
    def get_all(cls, session) -> dict[str, dict[str, str]]: ...

class DagModel(Base):
    """Table containing DAG properties."""

    __tablename__ = ...
    dag_id = ...
    root_dag_id = ...
    is_paused_at_creation = ...
    is_paused = ...
    is_subdag = ...
    is_active = ...
    last_parsed_time = ...
    last_pickled = ...
    last_expired = ...
    scheduler_lock = ...
    pickle_id = ...
    fileloc = ...
    processor_subdir = ...
    owners = ...
    _dag_display_property_value = ...
    description = ...
    default_view = ...
    schedule_interval = ...
    timetable_description = ...
    dataset_expression = ...
    tags = ...
    dag_owner_links = ...
    max_active_tasks = ...
    max_active_runs = ...
    max_consecutive_failed_dag_runs = ...
    has_task_concurrency_limits = ...
    has_import_errors = ...
    next_dagrun = ...
    next_dagrun_data_interval_start = ...
    next_dagrun_data_interval_end = ...
    next_dagrun_create_after = ...
    __table_args__ = ...
    parent_dag = ...
    schedule_dataset_references = ...
    schedule_dataset_alias_references = ...
    schedule_datasets = ...
    task_outlet_dataset_references = ...
    NUM_DAGS_PER_DAGRUN_QUERY = ...
    def __init__(self, concurrency=..., **kwargs) -> None: ...
    def __repr__(self):  # -> str:
        ...
    @property
    def next_dagrun_data_interval(self) -> DataInterval | None: ...
    @next_dagrun_data_interval.setter
    def next_dagrun_data_interval(
        self, value: tuple[datetime, datetime] | None
    ) -> None: ...
    @property
    def timezone(self):  # -> FixedTimezone | Timezone:
        ...
    @staticmethod
    @provide_session
    def get_dagmodel(dag_id: str, session: Session = ...) -> DagModel | None: ...
    @classmethod
    @internal_api_call
    @provide_session
    def get_current(cls, dag_id: str, session=...) -> DagModel | DagModelPydantic: ...
    @provide_session
    def get_last_dagrun(self, session=..., include_externally_triggered=...): ...
    def get_is_paused(self, *, session: Session | None = ...) -> bool:
        """Provide interface compatibility to 'DAG'."""
        ...

    def get_is_active(self, *, session: Session | None = ...) -> bool:
        """Provide interface compatibility to 'DAG'."""
        ...

    @staticmethod
    @internal_api_call
    @provide_session
    def get_paused_dag_ids(dag_ids: list[str], session: Session = ...) -> set[str]:
        """
        Given a list of dag_ids, get a set of Paused Dag Ids.

        :param dag_ids: List of Dag ids
        :param session: ORM Session
        :return: Paused Dag_ids
        """
        ...

    def get_default_view(self) -> str:
        """Get the Default DAG View, returns the default config value if DagModel does not have a value."""
        ...

    @property
    def safe_dag_id(self): ...
    @property
    def relative_fileloc(self) -> pathlib.Path | None:
        """File location of the importable dag 'file' relative to the configured DAGs folder."""
        ...

    @provide_session
    def set_is_paused(
        self, is_paused: bool, including_subdags: bool = ..., session=...
    ) -> None:
        """
        Pause/Un-pause a DAG.

        :param is_paused: Is the DAG paused
        :param including_subdags: whether to include the DAG's subdags
        :param session: session
        """
        ...

    @hybrid_property
    def dag_display_name(self) -> str: ...
    @classmethod
    @internal_api_call
    @provide_session
    def deactivate_deleted_dags(
        cls,
        alive_dag_filelocs: Container[str],
        processor_subdir: str,
        session: Session = ...,
    ) -> None:
        """
        Set ``is_active=False`` on the DAGs for which the DAG files have been removed.

        :param alive_dag_filelocs: file paths of alive DAGs
        :param processor_subdir: dag processor subdir
        :param session: ORM Session
        """
        ...

    @classmethod
    def dags_needing_dagruns(
        cls, session: Session
    ) -> tuple[Query, dict[str, tuple[datetime, datetime]]]:
        """
        Return (and lock) a list of Dag objects that are due to create a new DagRun.

        This will return a resultset of rows that is row-level-locked with a "SELECT ... FOR UPDATE" query,
        you should ensure that any scheduling decisions are made in a single transaction -- as soon as the
        transaction is committed it will be unlocked.
        """
        ...

    def calculate_dagrun_date_fields(
        self, dag: DAG, last_automated_dag_run: None | datetime | DataInterval
    ) -> None:
        """
        Calculate ``next_dagrun`` and `next_dagrun_create_after``.

        :param dag: The DAG object
        :param last_automated_dag_run: DataInterval (or datetime) of most recent run of this dag, or none
            if not yet scheduled.
        """
        ...

    @provide_session
    def get_dataset_triggered_next_run_info(
        self, *, session=...
    ) -> dict[str, int | str] | None: ...

def dag(
    dag_id: str = ...,
    description: str | None = ...,
    schedule: ScheduleArg = ...,
    schedule_interval: ScheduleIntervalArg = ...,
    timetable: Timetable | None = ...,
    start_date: datetime | None = ...,
    end_date: datetime | None = ...,
    full_filepath: str | None = ...,
    template_searchpath: str | Iterable[str] | None = ...,
    template_undefined: type[jinja2.StrictUndefined] = ...,
    user_defined_macros: dict | None = ...,
    user_defined_filters: dict | None = ...,
    default_args: dict | None = ...,
    concurrency: int | None = ...,
    max_active_tasks: int = ...,
    max_active_runs: int = ...,
    max_consecutive_failed_dag_runs: int = ...,
    dagrun_timeout: timedelta | None = ...,
    sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = ...,
    default_view: str = ...,
    orientation: str = ...,
    catchup: bool = ...,
    on_success_callback: None
    | DagStateChangeCallback
    | list[DagStateChangeCallback] = ...,
    on_failure_callback: None
    | DagStateChangeCallback
    | list[DagStateChangeCallback] = ...,
    doc_md: str | None = ...,
    params: abc.MutableMapping | None = ...,
    access_control: dict[str, dict[str, Collection[str]]]
    | dict[str, Collection[str]]
    | None = ...,
    is_paused_upon_creation: bool | None = ...,
    jinja_environment_kwargs: dict | None = ...,
    render_template_as_native_obj: bool = ...,
    tags: list[str] | None = ...,
    owner_links: dict[str, str] | None = ...,
    auto_register: bool = ...,
    fail_stop: bool = ...,
    dag_display_name: str | None = ...,
) -> Callable[[Callable], Callable[..., DAG]]:
    """
    Python dag decorator which wraps a function into an Airflow DAG.

    Accepts kwargs for operator kwarg. Can be used to parameterize DAGs.

    :param dag_args: Arguments for DAG object
    :param dag_kwargs: Kwargs for DAG object.
    """
    ...

STATICA_HACK = ...
if STATICA_HACK: ...

class DagContext:
    """
    DAG context is used to keep the current DAG when DAG is used as ContextManager.

    You can use DAG as context:

    .. code-block:: python

        with DAG(
            dag_id="example_dag",
            default_args=default_args,
            schedule="0 0 * * *",
            dagrun_timeout=timedelta(minutes=60),
        ) as dag: ...

    If you do this the context stores the DAG and whenever new task is created, it will use
    such stored DAG as the parent DAG.

    """

    _context_managed_dags: deque[DAG] = ...
    autoregistered_dags: set[tuple[DAG, ModuleType]] = ...
    current_autoregister_module_name: str | None = ...
    @classmethod
    def push_context_managed_dag(cls, dag: DAG):  # -> None:
        ...
    @classmethod
    def pop_context_managed_dag(cls) -> DAG | None: ...
    @classmethod
    def get_current_dag(cls) -> DAG | None: ...
