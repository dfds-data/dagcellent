"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable, Iterator
from datetime import datetime
from typing import TYPE_CHECKING, Any, NamedTuple, TypeVar

from airflow.api_internal.internal_api_call import internal_api_call
from airflow.callbacks.callback_requests import DagCallbackRequest
from airflow.models.base import Base
from airflow.models.dag import DAG
from airflow.models.taskinstance import TaskInstance as TI
from airflow.models.tasklog import LogTemplate
from airflow.serialization.pydantic.dag_run import DagRunPydantic
from airflow.serialization.pydantic.taskinstance import TaskInstancePydantic
from airflow.serialization.pydantic.tasklog import LogTemplatePydantic
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.utils.session import provide_session
from airflow.utils.state import DagRunState, TaskInstanceState
from airflow.utils.types import ArgNotSet, DagRunType
from sqlalchemy.orm import Query, Session, declared_attr, validates

if TYPE_CHECKING:
    CreatedTasks = TypeVar("CreatedTasks", Iterator["dict[str, Any]"], Iterator[TI])
RUN_ID_REGEX = ...

class TISchedulingDecision(NamedTuple):
    """Type of return for DagRun.task_instance_scheduling_decisions."""

    tis: list[TI]
    schedulable_tis: list[TI]
    changed_tis: bool
    unfinished_tis: list[TI]
    finished_tis: list[TI]
    ...

class DagRun(Base, LoggingMixin):
    """
    Invocation instance of a DAG.

    A DAG run can be created by the scheduler (i.e. scheduled runs), or by an
    external trigger (i.e. manual runs).
    """

    __tablename__ = ...
    id = ...
    dag_id = ...
    queued_at = ...
    execution_date = ...
    start_date = ...
    end_date = ...
    _state = ...
    run_id = ...
    creating_job_id = ...
    external_trigger = ...
    run_type = ...
    conf = ...
    data_interval_start = ...
    data_interval_end = ...
    last_scheduling_decision = ...
    dag_hash = ...
    log_template_id = ...
    updated_at = ...
    clear_number = ...
    if not TYPE_CHECKING and "BUILDING_AIRFLOW_DOCS" in os.environ: ...
    else:
        dag: DAG | None = ...
    __table_args__ = ...
    task_instances = ...
    dag_model = ...
    dag_run_note = ...
    note = ...
    DEFAULT_DAGRUNS_TO_EXAMINE = ...
    def __init__(
        self,
        dag_id: str | None = ...,
        run_id: str | None = ...,
        queued_at: datetime | None | ArgNotSet = ...,
        execution_date: datetime | None = ...,
        start_date: datetime | None = ...,
        external_trigger: bool | None = ...,
        conf: Any | None = ...,
        state: DagRunState | None = ...,
        run_type: str | None = ...,
        dag_hash: str | None = ...,
        creating_job_id: int | None = ...,
        data_interval: tuple[datetime, datetime] | None = ...,
    ) -> None: ...
    def __repr__(self):  # -> str:
        ...
    @validates("run_id")
    def validate_run_id(self, key: str, run_id: str) -> str | None: ...
    @property
    def stats_tags(self) -> dict[str, str]: ...
    @property
    def logical_date(self) -> datetime: ...
    def get_state(self):  # -> DagRunState:
        ...
    def set_state(self, state: DagRunState) -> None:
        """
        Change the state of the DagRan.

        Changes to attributes are implemented in accordance with the following table
        (rows represent old states, columns represent new states):

        .. list-table:: State transition matrix
           :header-rows: 1
           :stub-columns: 1

           * -
             - QUEUED
             - RUNNING
             - SUCCESS
             - FAILED
           * - None
             - queued_at = timezone.utcnow()
             - if empty: start_date = timezone.utcnow()
               end_date = None
             - end_date = timezone.utcnow()
             - end_date = timezone.utcnow()
           * - QUEUED
             - queued_at = timezone.utcnow()
             - if empty: start_date = timezone.utcnow()
               end_date = None
             - end_date = timezone.utcnow()
             - end_date = timezone.utcnow()
           * - RUNNING
             - queued_at = timezone.utcnow()
               start_date = None
               end_date = None
             -
             - end_date = timezone.utcnow()
             - end_date = timezone.utcnow()
           * - SUCCESS
             - queued_at = timezone.utcnow()
               start_date = None
               end_date = None
             - start_date = timezone.utcnow()
               end_date = None
             -
             -
           * - FAILED
             - queued_at = timezone.utcnow()
               start_date = None
               end_date = None
             - start_date = timezone.utcnow()
               end_date = None
             -
             -

        """
        ...

    @declared_attr
    def state(self): ...
    @provide_session
    def refresh_from_db(self, session: Session = ...) -> None:
        """
        Reload the current dagrun from the database.

        :param session: database session
        """
        ...

    @classmethod
    @provide_session
    def active_runs_of_dags(
        cls,
        dag_ids: Iterable[str] | None = ...,
        only_running: bool = ...,
        session: Session = ...,
    ) -> dict[str, int]:
        """Get the number of active dag runs for each dag."""
        ...

    @classmethod
    def next_dagruns_to_examine(
        cls, state: DagRunState, session: Session, max_number: int | None = ...
    ) -> Query:
        """
        Return the next DagRuns that the scheduler should attempt to schedule.

        This will return zero or more DagRun rows that are row-level-locked with a "SELECT ... FOR UPDATE"
        query, you should ensure that any scheduling decisions are made in a single transaction -- as soon as
        the transaction is committed it will be unlocked.

        """
        ...

    @classmethod
    @provide_session
    def find(
        cls,
        dag_id: str | list[str] | None = ...,
        run_id: Iterable[str] | None = ...,
        execution_date: datetime | Iterable[datetime] | None = ...,
        state: DagRunState | None = ...,
        external_trigger: bool | None = ...,
        no_backfills: bool = ...,
        run_type: DagRunType | None = ...,
        session: Session = ...,
        execution_start_date: datetime | None = ...,
        execution_end_date: datetime | None = ...,
    ) -> list[DagRun]:
        """
        Return a set of dag runs for the given search criteria.

        :param dag_id: the dag_id or list of dag_id to find dag runs for
        :param run_id: defines the run id for this dag run
        :param run_type: type of DagRun
        :param execution_date: the execution date
        :param state: the state of the dag run
        :param external_trigger: whether this dag run is externally triggered
        :param no_backfills: return no backfills (True), return all (False).
            Defaults to False
        :param session: database session
        :param execution_start_date: dag run that was executed from this date
        :param execution_end_date: dag run that was executed until this date
        """
        ...

    @classmethod
    @provide_session
    def find_duplicate(
        cls, dag_id: str, run_id: str, execution_date: datetime, session: Session = ...
    ) -> DagRun | None:
        """
        Return an existing run for the DAG with a specific run_id or execution_date.

        *None* is returned if no such DAG run is found.

        :param dag_id: the dag_id to find duplicates for
        :param run_id: defines the run id for this dag run
        :param execution_date: the execution date
        :param session: database session
        """
        ...

    @staticmethod
    def generate_run_id(run_type: DagRunType, execution_date: datetime) -> str:
        """Generate Run ID based on Run Type and Execution Date."""
        ...

    @staticmethod
    @internal_api_call
    @provide_session
    def fetch_task_instances(
        dag_id: str | None = ...,
        run_id: str | None = ...,
        task_ids: list[str] | None = ...,
        state: Iterable[TaskInstanceState | None] | None = ...,
        session: Session = ...,
    ) -> list[TI]:
        """Return the task instances for this dag run."""
        ...

    @provide_session
    def get_task_instances(
        self,
        state: Iterable[TaskInstanceState | None] | None = ...,
        session: Session = ...,
    ) -> list[TI]:
        """
        Return the task instances for this dag run.

        Redirect to DagRun.fetch_task_instances method.
        Keep this method because it is widely used across the code.
        """
        ...

    @provide_session
    def get_task_instance(
        self, task_id: str, session: Session = ..., *, map_index: int = ...
    ) -> TI | TaskInstancePydantic | None:
        """
        Return the task instance specified by task_id for this dag run.

        :param task_id: the task id
        :param session: Sqlalchemy ORM Session
        """
        ...

    @staticmethod
    @internal_api_call
    @provide_session
    def fetch_task_instance(
        dag_id: str,
        dag_run_id: str,
        task_id: str,
        session: Session = ...,
        map_index: int = ...,
    ) -> TI | TaskInstancePydantic | None:
        """
        Return the task instance specified by task_id for this dag run.

        :param dag_id: the DAG id
        :param dag_run_id: the DAG run id
        :param task_id: the task id
        :param session: Sqlalchemy ORM Session
        """
        ...

    def get_dag(self) -> DAG:
        """
        Return the Dag associated with this DagRun.

        :return: DAG
        """
        ...

    @staticmethod
    @internal_api_call
    @provide_session
    def get_previous_dagrun(
        dag_run: DagRun | DagRunPydantic,
        state: DagRunState | None = ...,
        session: Session = ...,
    ) -> DagRun | None:
        """
        Return the previous DagRun, if there is one.

        :param dag_run: the dag run
        :param session: SQLAlchemy ORM Session
        :param state: the dag run state
        """
        ...

    @staticmethod
    @internal_api_call
    @provide_session
    def get_previous_scheduled_dagrun(
        dag_run_id: int, session: Session = ...
    ) -> DagRun | None:
        """
        Return the previous SCHEDULED DagRun, if there is one.

        :param dag_run_id: the DAG run ID
        :param session: SQLAlchemy ORM Session
        """
        ...

    @provide_session
    def update_state(
        self, session: Session = ..., execute_callbacks: bool = ...
    ) -> tuple[list[TI], DagCallbackRequest | None]:
        """
        Determine the overall state of the DagRun based on the state of its TaskInstances.

        :param session: Sqlalchemy ORM Session
        :param execute_callbacks: Should dag callbacks (success/failure, SLA etc.) be invoked
            directly (default: true) or recorded as a pending request in the ``returned_callback`` property
        :return: Tuple containing tis that can be scheduled in the current loop & `returned_callback` that
            needs to be executed
        """
        class _UnfinishedStates(NamedTuple): ...

    @provide_session
    def task_instance_scheduling_decisions(
        self, session: Session = ...
    ) -> TISchedulingDecision: ...
    def notify_dagrun_state_changed(self, msg: str = ...):  # -> None:
        ...
    @provide_session
    def verify_integrity(self, *, session: Session = ...) -> None:
        """
        Verify the DagRun by checking for removed tasks or tasks that are not in the database yet.

        It will set state to removed or add the task if required.

        :missing_indexes: A dictionary of task vs indexes that are missing.
        :param session: Sqlalchemy ORM Session
        """
        ...

    @staticmethod
    def get_run(
        session: Session, dag_id: str, execution_date: datetime
    ) -> DagRun | None:
        """
        Get a single DAG Run.

        :meta private:
        :param session: Sqlalchemy ORM Session
        :param dag_id: DAG ID
        :param execution_date: execution date
        :return: DagRun corresponding to the given dag_id and execution date
            if one exists. None otherwise.
        """
        ...

    @property
    def is_backfill(self) -> bool: ...
    @classmethod
    @provide_session
    def get_latest_runs(cls, session: Session = ...) -> list[DagRun]:
        """Return the latest DagRun for each DAG."""
        ...

    @provide_session
    def schedule_tis(
        self,
        schedulable_tis: Iterable[TI],
        session: Session = ...,
        max_tis_per_query: int | None = ...,
    ) -> int:
        """
        Set the given task instances in to the scheduled state.

        Each element of ``schedulable_tis`` should have its ``task`` attribute already set.

        Any EmptyOperator without callbacks or outlets is instead set straight to the success state.

        All the TIs should belong to this DagRun, but this code is in the hot-path, this is not checked -- it
        is the caller's responsibility to call this function only with TIs from a single dag run.
        """
        ...

    @provide_session
    def get_log_template(
        self, *, session: Session = ...
    ) -> LogTemplate | LogTemplatePydantic: ...
    @provide_session
    def get_log_filename_template(self, *, session: Session = ...) -> str: ...

class DagRunNote(Base):
    """For storage of arbitrary notes concerning the dagrun instance."""

    __tablename__ = ...
    user_id = ...
    dag_run_id = ...
    content = ...
    created_at = ...
    updated_at = ...
    dag_run = ...
    __table_args__ = ...
    def __init__(self, content, user_id=...) -> None: ...
    def __repr__(self):  # -> str:
        ...
