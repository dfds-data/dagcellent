"""
This type stub file was generated by pyright.
"""

import datetime
from collections.abc import Collection, Iterable, Iterator, Mapping, Sequence
from typing import (
    TYPE_CHECKING,
    Any,
    ClassVar,
    Union,
)

import attr
import jinja2
import methodtools
import pendulum
from airflow.models.abstractoperator import AbstractOperator, TaskStateChangeCallback
from airflow.models.baseoperator import BaseOperator
from airflow.models.baseoperatorlink import BaseOperatorLink
from airflow.models.dag import DAG
from airflow.models.expandinput import (
    ExpandInput,
    OperatorExpandArgument,
    OperatorExpandKwargsArgument,
)
from airflow.models.operator import Operator
from airflow.models.param import ParamsDict
from airflow.models.xcom_arg import XComArg
from airflow.serialization.enums import DagAttributeTypes
from airflow.task.priority_strategy import PriorityWeightStrategy
from airflow.ti_deps.deps.base_ti_dep import BaseTIDep
from airflow.triggers.base import StartTriggerArgs
from airflow.typing_compat import Literal
from airflow.utils.context import Context
from airflow.utils.operator_resources import Resources
from airflow.utils.task_group import TaskGroup
from airflow.utils.trigger_rule import TriggerRule
from sqlalchemy.orm.session import Session

if TYPE_CHECKING:
    TaskStateChangeCallbackAttrType = Union[
        None, TaskStateChangeCallback, list[TaskStateChangeCallback]
    ]
ValidationSource = Union[Literal["expand"], Literal["partial"]]

def validate_mapping_kwargs(
    op: type[BaseOperator], func: ValidationSource, value: dict[str, Any]
) -> None: ...
def ensure_xcomarg_return_value(arg: Any) -> None: ...
@attr.define(kw_only=True, repr=False)
class OperatorPartial:
    """
    An "intermediate state" returned by ``BaseOperator.partial()``.

    This only exists at DAG-parsing time; the only intended usage is for the
    user to call ``.expand()`` on it at some point (usually in a method chain) to
    create a ``MappedOperator`` to add into the DAG.
    """

    operator_class: type[BaseOperator]
    kwargs: dict[str, Any]
    params: ParamsDict | dict
    _expand_called: bool = ...
    def __attrs_post_init__(self):  # -> None:
        ...
    def __repr__(self) -> str: ...
    def __del__(self):  # -> None:
        ...
    def expand(self, **mapped_kwargs: OperatorExpandArgument) -> MappedOperator: ...
    def expand_kwargs(
        self, kwargs: OperatorExpandKwargsArgument, *, strict: bool = ...
    ) -> MappedOperator: ...

@attr.define(kw_only=True, getstate_setstate=False)
class MappedOperator(AbstractOperator):
    """Object representing a mapped operator in a DAG."""

    operator_class: type[BaseOperator] | dict[str, Any]
    expand_input: ExpandInput
    partial_kwargs: dict[str, Any]
    task_id: str
    params: ParamsDict | dict
    deps: frozenset[BaseTIDep]
    operator_extra_links: Collection[BaseOperatorLink]
    template_ext: Sequence[str]
    template_fields: Collection[str]
    template_fields_renderers: dict[str, str]
    ui_color: str
    ui_fgcolor: str
    _is_empty: bool
    _task_module: str
    _task_type: str
    _operator_name: str
    start_trigger_args: StartTriggerArgs | None
    start_from_trigger: bool
    _needs_expansion: bool = ...
    dag: DAG | None
    task_group: TaskGroup | None
    start_date: pendulum.DateTime | None
    end_date: pendulum.DateTime | None
    upstream_task_ids: set[str] = ...
    downstream_task_ids: set[str] = ...
    _disallow_kwargs_override: bool
    _expand_input_attr: str
    subdag: None = ...
    supports_lineage: bool = ...
    HIDE_ATTRS_FROM_UI: ClassVar[frozenset[str]] = ...
    def __hash__(self) -> int: ...
    def __repr__(self):  # -> str:
        ...
    def __attrs_post_init__(self):  # -> None:
        ...
    @methodtools.lru_cache(maxsize=None)
    @classmethod
    def get_serialized_fields(cls):  # -> frozenset[str]:
        ...
    @methodtools.lru_cache(maxsize=None)
    @staticmethod
    def deps_for(operator_class: type[BaseOperator]) -> frozenset[BaseTIDep]: ...
    @property
    def task_type(self) -> str:
        """Implementing Operator."""
        ...

    @property
    def operator_name(self) -> str: ...
    @property
    def inherits_from_empty_operator(self) -> bool:
        """Implementing Operator."""
        ...

    @property
    def roots(self) -> Sequence[AbstractOperator]:
        """Implementing DAGNode."""
        ...

    @property
    def leaves(self) -> Sequence[AbstractOperator]:
        """Implementing DAGNode."""
        ...

    @property
    def task_display_name(self) -> str: ...
    @property
    def owner(self) -> str: ...
    @property
    def email(self) -> None | str | Iterable[str]: ...
    @property
    def map_index_template(self) -> None | str: ...
    @map_index_template.setter
    def map_index_template(self, value: str | None) -> None: ...
    @property
    def trigger_rule(self) -> TriggerRule: ...
    @trigger_rule.setter
    def trigger_rule(self, value):  # -> None:
        ...
    @property
    def is_setup(self) -> bool: ...
    @is_setup.setter
    def is_setup(self, value: bool) -> None: ...
    @property
    def is_teardown(self) -> bool: ...
    @is_teardown.setter
    def is_teardown(self, value: bool) -> None: ...
    @property
    def depends_on_past(self) -> bool: ...
    @depends_on_past.setter
    def depends_on_past(self, value: bool) -> None: ...
    @property
    def ignore_first_depends_on_past(self) -> bool: ...
    @ignore_first_depends_on_past.setter
    def ignore_first_depends_on_past(self, value: bool) -> None: ...
    @property
    def wait_for_past_depends_before_skipping(self) -> bool: ...
    @wait_for_past_depends_before_skipping.setter
    def wait_for_past_depends_before_skipping(self, value: bool) -> None: ...
    @property
    def wait_for_downstream(self) -> bool: ...
    @wait_for_downstream.setter
    def wait_for_downstream(self, value: bool) -> None: ...
    @property
    def retries(self) -> int: ...
    @retries.setter
    def retries(self, value: int) -> None: ...
    @property
    def queue(self) -> str: ...
    @queue.setter
    def queue(self, value: str) -> None: ...
    @property
    def pool(self) -> str: ...
    @pool.setter
    def pool(self, value: str) -> None: ...
    @property
    def pool_slots(self) -> int: ...
    @pool_slots.setter
    def pool_slots(self, value: int) -> None: ...
    @property
    def execution_timeout(self) -> datetime.timedelta | None: ...
    @execution_timeout.setter
    def execution_timeout(self, value: datetime.timedelta | None) -> None: ...
    @property
    def max_retry_delay(self) -> datetime.timedelta | None: ...
    @max_retry_delay.setter
    def max_retry_delay(self, value: datetime.timedelta | None) -> None: ...
    @property
    def retry_delay(self) -> datetime.timedelta: ...
    @retry_delay.setter
    def retry_delay(self, value: datetime.timedelta) -> None: ...
    @property
    def retry_exponential_backoff(self) -> bool: ...
    @retry_exponential_backoff.setter
    def retry_exponential_backoff(self, value: bool) -> None: ...
    @property
    def priority_weight(self) -> int: ...
    @priority_weight.setter
    def priority_weight(self, value: int) -> None: ...
    @property
    def weight_rule(self) -> PriorityWeightStrategy: ...
    @weight_rule.setter
    def weight_rule(self, value: str | PriorityWeightStrategy) -> None: ...
    @property
    def sla(self) -> datetime.timedelta | None: ...
    @sla.setter
    def sla(self, value: datetime.timedelta | None) -> None: ...
    @property
    def max_active_tis_per_dag(self) -> int | None: ...
    @max_active_tis_per_dag.setter
    def max_active_tis_per_dag(self, value: int | None) -> None: ...
    @property
    def max_active_tis_per_dagrun(self) -> int | None: ...
    @max_active_tis_per_dagrun.setter
    def max_active_tis_per_dagrun(self, value: int | None) -> None: ...
    @property
    def resources(self) -> Resources | None: ...
    @property
    def on_execute_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_execute_callback.setter
    def on_execute_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_failure_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_failure_callback.setter
    def on_failure_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_retry_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_retry_callback.setter
    def on_retry_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_success_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_success_callback.setter
    def on_success_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def on_skipped_callback(self) -> TaskStateChangeCallbackAttrType: ...
    @on_skipped_callback.setter
    def on_skipped_callback(self, value: TaskStateChangeCallbackAttrType) -> None: ...
    @property
    def run_as_user(self) -> str | None: ...
    @property
    def executor(self) -> str | None: ...
    @property
    def executor_config(self) -> dict: ...
    @property
    def inlets(self) -> list[Any]: ...
    @inlets.setter
    def inlets(self, value: list[Any]) -> None: ...
    @property
    def outlets(self) -> list[Any]: ...
    @outlets.setter
    def outlets(self, value: list[Any]) -> None: ...
    @property
    def doc(self) -> str | None: ...
    @property
    def doc_md(self) -> str | None: ...
    @property
    def doc_json(self) -> str | None: ...
    @property
    def doc_yaml(self) -> str | None: ...
    @property
    def doc_rst(self) -> str | None: ...
    @property
    def allow_nested_operators(self) -> bool: ...
    def get_dag(self) -> DAG | None:
        """Implement Operator."""
        ...

    @property
    def output(self) -> XComArg:
        """Return reference to XCom pushed by current operator."""
        ...

    def serialize_for_task_group(self) -> tuple[DagAttributeTypes, Any]:
        """Implement DAGNode."""
        ...

    def expand_start_from_trigger(self, *, context: Context, session: Session) -> bool:
        """
        Get the start_from_trigger value of the current abstract operator.

        MappedOperator uses this to unmap start_from_trigger to decide whether to start the task
        execution directly from triggerer.

        :meta private:
        """
        ...

    def expand_start_trigger_args(
        self, *, context: Context, session: Session
    ) -> StartTriggerArgs | None:
        """
        Get the kwargs to create the unmapped start_trigger_args.

        This method is for allowing mapped operator to start execution from triggerer.
        """
        ...

    def unmap(
        self, resolve: None | Mapping[str, Any] | tuple[Context, Session]
    ) -> BaseOperator:
        """
        Get the "normal" Operator after applying the current mapping.

        The *resolve* argument is only used if ``operator_class`` is a real
        class, i.e. if this operator is not serialized. If ``operator_class`` is
        not a class (i.e. this DAG has been deserialized), this returns a
        SerializedBaseOperator that "looks like" the actual unmapping result.

        If *resolve* is a two-tuple (context, session), the information is used
        to resolve the mapped arguments into init arguments. If it is a mapping,
        no resolving happens, the mapping directly provides those init arguments
        resolved from mapped kwargs.

        :meta private:
        """
        ...

    def prepare_for_execution(self) -> MappedOperator: ...
    def iter_mapped_dependencies(self) -> Iterator[Operator]:
        """Upstream dependencies that provide XComs used by this task for task mapping."""
        ...

    @methodtools.lru_cache(maxsize=None)
    def get_parse_time_mapped_ti_count(self) -> int: ...
    def get_mapped_ti_count(self, run_id: str, *, session: Session) -> int: ...
    def render_template_fields(
        self, context: Context, jinja_env: jinja2.Environment | None = ...
    ) -> None:
        """
        Template all attributes listed in *self.template_fields*.

        This updates *context* to reference the map-expanded task and relevant
        information, without modifying the mapped operator. The expanded task
        in *context* is then rendered in-place.

        :param context: Context dict with values to apply on content.
        :param jinja_env: Jinja environment to use for rendering.
        """
        ...
