"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Iterable, Iterator, Mapping, Sequence
from typing import TYPE_CHECKING, Any, overload

from airflow.models.baseoperator import BaseOperator
from airflow.models.dag import DAG
from airflow.models.operator import Operator
from airflow.models.taskmixin import DAGNode, DependencyMixin
from airflow.utils.context import Context
from airflow.utils.edgemodifier import EdgeModifier
from airflow.utils.mixins import ResolveMixin
from airflow.utils.session import provide_session
from airflow.utils.types import ArgNotSet
from sqlalchemy.orm import Session

if TYPE_CHECKING: ...
MapCallables = Sequence[Callable[[Any], Any] | str]

class XComArg(ResolveMixin, DependencyMixin):
    """
    Reference to an XCom value pushed from another operator.

    The implementation supports::

        xcomarg >> op
        xcomarg << op
        op >> xcomarg  # By BaseOperator code
        op << xcomarg  # By BaseOperator code

    **Example**: The moment you get a result from any operator (decorated or regular) you can ::

        any_op = AnyOperator()
        xcomarg = XComArg(any_op)
        # or equivalently
        xcomarg = any_op.output
        my_op = MyOperator()
        my_op >> xcomarg

    This object can be used in legacy Operators via Jinja.

    **Example**: You can make this result to be part of any generated string::

        any_op = AnyOperator()
        xcomarg = any_op.output
        op1 = MyOperator(my_text_message=f"the value is {xcomarg}")
        op2 = MyOperator(my_text_message=f"the value is {xcomarg['topic']}")

    :param operator: Operator instance to which the XComArg references.
    :param key: Key used to pull the XCom value. Defaults to *XCOM_RETURN_KEY*,
        i.e. the referenced operator's return value.
    """

    @overload
    def __new__(cls: type[XComArg], operator: Operator, key: str = ...) -> XComArg:
        """Execute when the user writes ``XComArg(...)`` directly."""
        ...

    @overload
    def __new__(cls: type[XComArg]) -> XComArg:
        """Execute by Python internals from subclasses."""
        ...

    def __new__(cls, *args, **kwargs) -> XComArg: ...
    @staticmethod
    def iter_xcom_references(arg: Any) -> Iterator[tuple[Operator, str]]:
        """
        Return XCom references in an arbitrary value.

        Recursively traverse ``arg`` and look for XComArg instances in any
        collection objects, and instances with ``template_fields`` set.
        """
        ...

    @staticmethod
    def apply_upstream_relationship(op: Operator, arg: Any):  # -> None:
        """
        Set dependency for XComArgs.

        This looks for XComArg objects in ``arg`` "deeply" (looking inside
        collections objects and classes decorated with ``template_fields``), and
        sets the relationship to ``op`` on any found.
        """
        ...

    @property
    def roots(self) -> list[DAGNode]:
        """Required by TaskMixin."""
        ...

    @property
    def leaves(self) -> list[DAGNode]:
        """Required by TaskMixin."""
        ...

    def set_upstream(
        self,
        task_or_task_list: DependencyMixin | Sequence[DependencyMixin],
        edge_modifier: EdgeModifier | None = ...,
    ):  # -> None:
        """Proxy to underlying operator set_upstream method. Required by TaskMixin."""
        ...

    def set_downstream(
        self,
        task_or_task_list: DependencyMixin | Sequence[DependencyMixin],
        edge_modifier: EdgeModifier | None = ...,
    ):  # -> None:
        """Proxy to underlying operator set_downstream method. Required by TaskMixin."""
        ...

    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def zip(self, *others: XComArg, fillvalue: Any = ...) -> ZipXComArg: ...
    def concat(self, *others: XComArg) -> ConcatXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None:
        """
        Inspect length of pushed value for task-mapping.

        This is used to determine how many task instances the scheduler should
        create for a downstream using this XComArg for task-mapping.

        *None* may be returned if the depended XCom has not been pushed.
        """
        ...

    @provide_session
    def resolve(
        self, context: Context, session: Session = ..., *, include_xcom: bool = ...
    ) -> Any:
        """
        Pull XCom value.

        This should only be called during ``op.execute()`` with an appropriate
        context (e.g. generated from ``TaskInstance.get_template_context()``).
        Although the ``ResolveMixin`` parent mixin also has a ``resolve``
        protocol, this adds the optional ``session`` argument that some of the
        subclasses need.

        :meta private:
        """
        ...

    def __enter__(self):  # -> type[SetupTeardownContext]:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...

class PlainXComArg(XComArg):
    """
    Reference to one single XCom without any additional semantics.

    This class should not be accessed directly, but only through XComArg. The
    class inheritance chain and ``__new__`` is implemented in this slightly
    convoluted way because we want to

    a. Allow the user to continue using XComArg directly for the simple
       semantics (see documentation of the base class for details).
    b. Make ``isinstance(thing, XComArg)`` be able to detect all kinds of XCom
       references.
    c. Not allow many properties of PlainXComArg (including ``__getitem__`` and
       ``__str__``) to exist on other kinds of XComArg implementations since
       they don't make sense.

    :meta private:
    """

    def __init__(self, operator: Operator, key: str = ...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __getitem__(self, item: str) -> XComArg:
        """Implement xcomresult['some_result_key']."""
        ...

    def __iter__(self):
        """
        Override iterable protocol to raise error explicitly.

        The default ``__iter__`` implementation in Python calls ``__getitem__``
        with 0, 1, 2, etc. until it hits an ``IndexError``. This does not work
        well with our custom ``__getitem__`` implementation, and results in poor
        DAG-writing experience since a misplaced ``*`` expansion would create an
        infinite loop consuming the entire DAG parser.

        This override catches the error eagerly, so an incorrectly implemented
        DAG fails fast and avoids wasting resources on nonsensical iterating.
        """
        ...

    def __repr__(self) -> str: ...
    def __str__(self) -> str:
        """
        Backward compatibility for old-style jinja used in Airflow Operators.

        **Example**: to use XComArg at BashOperator::

            BashOperator(cmd=f"... {xcomarg} ...")

        :return:
        """
        ...

    @property
    def is_setup(self) -> bool: ...
    @is_setup.setter
    def is_setup(self, val: bool):  # -> None:
        ...
    @property
    def is_teardown(self) -> bool: ...
    @is_teardown.setter
    def is_teardown(self, val: bool):  # -> None:
        ...
    @property
    def on_failure_fail_dagrun(self) -> bool: ...
    @on_failure_fail_dagrun.setter
    def on_failure_fail_dagrun(self, val: bool):  # -> None:
        ...
    def as_setup(self) -> DependencyMixin: ...
    def as_teardown(
        self,
        *,
        setups: BaseOperator | Iterable[BaseOperator] | ArgNotSet = ...,
        on_failure_fail_dagrun=...,
    ):  # -> Self:
        ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def zip(self, *others: XComArg, fillvalue: Any = ...) -> ZipXComArg: ...
    def concat(self, *others: XComArg) -> ConcatXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    @provide_session
    def resolve(
        self, context: Context, session: Session = ..., *, include_xcom: bool = ...
    ) -> Any: ...

class _MapResult(Sequence):
    def __init__(self, value: Sequence | dict, callables: MapCallables) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class MapXComArg(XComArg):
    """
    An XCom reference with ``map()`` call(s) applied.

    This is based on an XComArg, but also applies a series of "transforms" that
    convert the pulled XCom value.

    :meta private:
    """

    def __init__(self, arg: XComArg, callables: MapCallables) -> None: ...
    def __repr__(self) -> str: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def map(self, f: Callable[[Any], Any]) -> MapXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    @provide_session
    def resolve(
        self, context: Context, session: Session = ..., *, include_xcom: bool = ...
    ) -> Any: ...

class _ZipResult(Sequence):
    def __init__(
        self, values: Sequence[Sequence | dict], *, fillvalue: Any = ...
    ) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class ZipXComArg(XComArg):
    """
    An XCom reference with ``zip()`` applied.

    This is constructed from multiple XComArg instances, and presents an
    iterable that "zips" them together like the built-in ``zip()`` (and
    ``itertools.zip_longest()`` if ``fillvalue`` is provided).
    """

    def __init__(self, args: Sequence[XComArg], *, fillvalue: Any = ...) -> None: ...
    def __repr__(self) -> str: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    @provide_session
    def resolve(
        self, context: Context, session: Session = ..., *, include_xcom: bool = ...
    ) -> Any: ...

class _ConcatResult(Sequence):
    def __init__(self, values: Sequence[Sequence | dict]) -> None: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __len__(self) -> int: ...

class ConcatXComArg(XComArg):
    """
    Concatenating multiple XCom references into one.

    This is done by calling ``concat()`` on an XComArg to combine it with
    others. The effect is similar to Python's :func:`itertools.chain`, but the
    return value also supports index access.
    """

    def __init__(self, args: Sequence[XComArg]) -> None: ...
    def __repr__(self) -> str: ...
    def iter_references(self) -> Iterator[tuple[Operator, str]]: ...
    def concat(self, *others: XComArg) -> ConcatXComArg: ...
    def get_task_map_length(self, run_id: str, *, session: Session) -> int | None: ...
    @provide_session
    def resolve(
        self, context: Context, session: Session = ..., *, include_xcom: bool = ...
    ) -> Any: ...

_XCOM_ARG_TYPES: Mapping[str, type[XComArg]] = ...

def serialize_xcom_arg(value: XComArg) -> dict[str, Any]:
    """DAG serialization interface."""
    ...

def deserialize_xcom_arg(data: dict[str, Any], dag: DAG) -> XComArg:
    """DAG serialization interface."""
    ...
