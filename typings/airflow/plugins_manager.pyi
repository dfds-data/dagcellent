"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable
from types import ModuleType
from typing import TYPE_CHECKING, Any

import importlib_metadata as metadata
from airflow.hooks.base import BaseHook
from airflow.lineage.hook import HookLineageReader
from airflow.listeners.listener import ListenerManager
from airflow.task.priority_strategy import PriorityWeightStrategy
from airflow.timetables.base import Timetable

"""Manages all plugins."""
if TYPE_CHECKING: ...
log = ...
import_errors: dict[str, str] = ...
plugins: list[AirflowPlugin] | None = ...
loaded_plugins: set[str] = ...
registered_hooks: list[BaseHook] | None = ...
macros_modules: list[Any] | None = ...
executors_modules: list[Any] | None = ...
admin_views: list[Any] | None = ...
flask_blueprints: list[Any] | None = ...
menu_links: list[Any] | None = ...
flask_appbuilder_views: list[Any] | None = ...
flask_appbuilder_menu_links: list[Any] | None = ...
global_operator_extra_links: list[Any] | None = ...
operator_extra_links: list[Any] | None = ...
registered_operator_link_classes: dict[str, type] | None = ...
registered_ti_dep_classes: dict[str, type] | None = ...
timetable_classes: dict[str, type[Timetable]] | None = ...
hook_lineage_reader_classes: list[type[HookLineageReader]] | None = ...
priority_weight_strategy_classes: dict[str, type[PriorityWeightStrategy]] | None = ...
PLUGINS_ATTRIBUTES_TO_DUMP = ...

class AirflowPluginSource:
    """Class used to define an AirflowPluginSource."""

    def __str__(self) -> str: ...
    def __html__(self): ...

class PluginsDirectorySource(AirflowPluginSource):
    """Class used to define Plugins loaded from Plugins Directory."""

    def __init__(self, path) -> None: ...
    def __str__(self) -> str: ...
    def __html__(self):  # -> str:
        ...

class EntryPointSource(AirflowPluginSource):
    """Class used to define Plugins loaded from entrypoint."""

    def __init__(
        self, entrypoint: metadata.EntryPoint, dist: metadata.Distribution
    ) -> None: ...
    def __str__(self) -> str: ...
    def __html__(self):  # -> str:
        ...

class AirflowPluginException(Exception):
    """Exception when loading plugin."""

    ...

class AirflowPlugin:
    """Class used to define AirflowPlugin."""

    name: str | None = ...
    source: AirflowPluginSource | None = ...
    hooks: list[Any] = ...
    executors: list[Any] = ...
    macros: list[Any] = ...
    admin_views: list[Any] = ...
    flask_blueprints: list[Any] = ...
    menu_links: list[Any] = ...
    appbuilder_views: list[Any] = ...
    appbuilder_menu_items: list[Any] = ...
    global_operator_extra_links: list[Any] = ...
    operator_extra_links: list[Any] = ...
    ti_deps: list[Any] = ...
    timetables: list[type[Timetable]] = ...
    listeners: list[ModuleType | object] = ...
    hook_lineage_readers: list[type[HookLineageReader]] = ...
    priority_weight_strategies: list[type[PriorityWeightStrategy]] = ...
    @classmethod
    def validate(cls):  # -> None:
        """Validate if plugin has a name."""
        ...

    @classmethod
    def on_load(cls, *args, **kwargs):  # -> None:
        """
        Execute when the plugin is loaded; This method is only called once during runtime.

        :param args: If future arguments are passed in on call.
        :param kwargs: If future arguments are passed in on call.
        """
        ...

def is_valid_plugin(plugin_obj):  # -> bool:
    """
    Check whether a potential object is a subclass of the AirflowPlugin class.

    :param plugin_obj: potential subclass of AirflowPlugin
    :return: Whether or not the obj is a valid subclass of
        AirflowPlugin
    """
    ...

def register_plugin(plugin_instance):  # -> None:
    """
    Start plugin load and register it after success initialization.

    If plugin is already registered, do nothing.

    :param plugin_instance: subclass of AirflowPlugin
    """
    ...

def load_entrypoint_plugins():  # -> None:
    """
    Load and register plugins AirflowPlugin subclasses from the entrypoints.

    The entry_point group should be 'airflow.plugins'.
    """
    ...

def load_plugins_from_plugin_directory():  # -> None:
    """Load and register Airflow Plugins from plugins directory."""
    ...

def load_providers_plugins():  # -> None:
    ...
def make_module(name: str, objects: list[Any]):  # -> ModuleType | None:
    """Create new module."""
    ...

def ensure_plugins_loaded():  # -> None:
    """
    Load plugins from plugins directory and entrypoints.

    Plugins are only loaded if they have not been previously loaded.
    """
    ...

def initialize_web_ui_plugins():  # -> None:
    """Collect extension points for WEB UI."""
    ...

def initialize_ti_deps_plugins():  # -> None:
    """Create modules for loaded extension from custom task instance dependency rule plugins."""
    ...

def initialize_extra_operators_links_plugins():  # -> None:
    """Create modules for loaded extension from extra operators links plugins."""
    ...

def initialize_timetables_plugins():  # -> None:
    """Collect timetable classes registered by plugins."""
    ...

def initialize_hook_lineage_readers_plugins():  # -> None:
    """Collect hook lineage reader classes registered by plugins."""
    ...

def integrate_executor_plugins() -> None:
    """Integrate executor plugins to the context."""
    ...

def integrate_macros_plugins() -> None:
    """Integrates macro plugins."""
    ...

def integrate_listener_plugins(listener_manager: ListenerManager) -> None:
    """Add listeners from plugins."""
    ...

def get_plugin_info(attrs_to_dump: Iterable[str] | None = ...) -> list[dict[str, Any]]:
    """
    Dump plugins attributes.

    :param attrs_to_dump: A list of plugin attributes to dump
    """
    ...

def initialize_priority_weight_strategy_plugins():  # -> None:
    """Collect priority weight strategy classes registered by plugins."""
    ...
