"""
This type stub file was generated by pyright.
"""

from collections.abc import Collection, Sequence
from functools import cached_property
from typing import TYPE_CHECKING, Any

from airflow import models
from airflow.auth.managers.models.resource_details import AccessView, DagAccessEntity
from airflow.configuration import conf
from airflow.jobs.job import Job
from airflow.models import Connection, DagModel, Log, SlaMiss, XCom
from airflow.models.dagrun import DagRun
from airflow.models.taskinstance import TaskInstance
from airflow.security import permissions
from airflow.utils.session import provide_session
from airflow.utils.state import TaskInstanceState
from airflow.www import auth, utils as wwwutils
from airflow.www.decorators import action_logging, gzipped
from airflow.www.forms import DagRunEditForm, TaskInstanceEditForm
from airflow.www.widgets import AirflowModelListWidget, AirflowVariableShowWidget
from flask_appbuilder import BaseView, ModelView, expose
from flask_appbuilder.actions import action
from flask_appbuilder.models.sqla.filters import BaseFilter
from flask_appbuilder.widgets import FormWidget
from flask_babel import lazy_gettext
from sqlalchemy.orm import Session

if TYPE_CHECKING: ...
PAGE_SIZE = ...
FILTER_TAGS_COOKIE = ...
FILTER_STATUS_COOKIE = ...
FILTER_LASTRUN_COOKIE = ...
LINECHART_X_AXIS_TICKFORMAT = ...
SENSITIVE_FIELD_PLACEHOLDER = ...
logger = ...

def sanitize_args(args: dict[str, Any]) -> dict[str, Any]:
    """
    Remove all parameters starting with `_`.

    :param args: arguments of request
    :return: copy of the dictionary passed as input with args starting with `_` removed.
    """
    ...

_WHATWG_C0_CONTROL_OR_SPACE = ...

def get_safe_url(url):  # -> str:
    """Given a user-supplied URL, ensure it points to our web server."""
    ...

def get_date_time_num_runs_dag_runs_form_data(
    www_request, session, dag
):  # -> dict[str, Any]:
    """Get Execution Data, Base Date & Number of runs from a Request."""
    ...

def node_dict(node_id, label, node_class):  # -> dict[str, Any]:
    ...
def dag_to_grid(
    dag: DagModel, dag_runs: Sequence[DagRun], session: Session
) -> dict[str, Any]:
    """
    Create a nested dict representation of the DAG's TaskGroup and its children.

    Used to construct the Graph and Grid views.
    """
    ...

def get_key_paths(input_dict):  # -> Generator[str | Any, Any, None]:
    """Return a list of dot-separated dictionary paths."""
    ...

def get_value_from_path(key_path, content):
    """Return the value from a dictionary based on dot-separated path of keys."""
    ...

def get_task_stats_from_query(qry):  # -> dict[Any, Any]:
    """
    Return a dict of the task quantity, grouped by dag id and task status.

    :param qry: The data in the format (<dag id>, <task state>, <is dag running>, <task count>),
        ordered by <dag id> and <is dag running>
    """
    ...

def redirect_or_json(
    origin, msg, status=..., status_code=...
):  # -> flask.wrappers.Response | werkzeug.wrappers.response.Response:
    """
    Return json which allows us to more elegantly handle side effects in-page.

    This is useful because some endpoints are called by javascript.
    """
    ...

def not_found(error):  # -> tuple[str, Literal[404]]:
    """Show Not Found on screen for any error in the Webserver."""
    ...

def method_not_allowed(error):  # -> tuple[str, Literal[405]]:
    """Show Method Not Allowed on screen for any error in the Webserver."""
    ...

def show_traceback(
    error,
):  # -> tuple[Literal['Error calling the API'], Literal[500]] | tuple[str, Literal[500]]:
    """Show Traceback for a given error."""
    ...

class AirflowBaseView(BaseView):
    """Base View to set Airflow related properties."""

    route_base = ...
    extra_args = ...
    if not conf.getboolean("core", "unit_test_mode"): ...
    line_chart_attr = ...
    def render_template(self, *args, **kwargs):  # -> str:
        ...

class Airflow(AirflowBaseView):
    """Main Airflow application."""

    @expose("/health")
    def health(self):  # -> Response:
        """
        Check the health status of the Airflow instance.

        Includes metadatabase, scheduler and triggerer.
        """
        ...

    @expose("/home")
    @auth.has_access_view()
    def index(self):  # -> Response | str:
        """Home view."""
        ...

    @expose("/datasets")
    @auth.has_access_dataset("GET")
    def datasets(self):  # -> str:
        """Datasets view."""
        ...

    @expose("/cluster_activity")
    @auth.has_access_view(AccessView.CLUSTER_ACTIVITY)
    def cluster_activity(self):  # -> str:
        """Cluster Activity view."""
        ...

    @expose("/next_run_datasets_summary", methods=["POST"])
    @provide_session
    def next_run_datasets_summary(self, session: Session = ...):  # -> Response:
        """Next run info for dataset triggered DAGs."""
        ...

    @expose("/dag_stats", methods=["POST"])
    @auth.has_access_dag("GET", DagAccessEntity.RUN)
    @provide_session
    def dag_stats(self, session: Session = ...):  # -> Response:
        """Dag statistics."""
        ...

    @expose("/task_stats", methods=["POST"])
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def task_stats(self, session: Session = ...):  # -> Response:
        """Task Statistics."""
        ...

    @expose("/last_dagruns", methods=["POST"])
    @auth.has_access_dag("GET", DagAccessEntity.RUN)
    @provide_session
    def last_dagruns(self, session: Session = ...):  # -> Response:
        """Last DAG runs."""
        ...

    @expose("/code")
    def legacy_code(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/code")
    @auth.has_access_dag("GET", DagAccessEntity.CODE)
    def code(self, dag_id):  # -> Response:
        """Dag Code."""
        ...

    @expose("/dag_details")
    def legacy_dag_details(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/details")
    def dag_details(self, dag_id):  # -> Response:
        """Get Dag details."""
        ...

    @expose("/rendered-templates")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def rendered_templates(self, session):  # -> str:
        """Get rendered Dag."""
        ...

    @expose("/rendered-k8s")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def rendered_k8s(self, *, session: Session = ...):  # -> str:
        """Get rendered k8s yaml."""
        ...

    @expose("/object/rendered-k8s")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def rendered_k8s_data(
        self, *, session: Session = ...
    ):  # -> tuple[dict[str, str], Literal[404]] | tuple[dict[str, str], Literal[500]] | tuple[dict[str, Markup], Literal[500]]:
        """Get rendered k8s yaml."""
        ...

    @expose("/get_logs_with_metadata")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @auth.has_access_dag("GET", DagAccessEntity.TASK_LOGS)
    @provide_session
    def get_logs_with_metadata(
        self, session: Session = ...
    ):  # -> tuple[dict[str, str], Literal[400]] | dict[str, Any] | Response:
        """Retrieve logs including metadata."""
        ...

    @expose("/log")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_LOGS)
    @provide_session
    def log(self, session: Session = ...):  # -> str:
        """Retrieve log."""
        ...

    @expose("/redirect_to_external_log")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_LOGS)
    @provide_session
    def redirect_to_external_log(self, session: Session = ...):  # -> Response:
        """Redirects to external log."""
        ...

    @expose("/task")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def task(self, session: Session = ...):  # -> Response | str:
        """Retrieve task."""
        ...

    @expose("/xcom")
    @auth.has_access_dag("GET", DagAccessEntity.XCOM)
    @provide_session
    def xcom(self, session: Session = ...):  # -> Response | str:
        """Retrieve XCOM."""
        ...

    @expose("/delete", methods=["POST"])
    @auth.has_access_dag("DELETE")
    @action_logging
    def delete(self):  # -> Response:
        """Delete DAG."""
        ...

    @expose("/dags/<string:dag_id>/trigger", methods=["POST", "GET"])
    @auth.has_access_dag("POST", DagAccessEntity.RUN)
    @action_logging
    @provide_session
    def trigger(self, dag_id: str, session: Session = ...):  # -> Response | str:
        """Triggers DAG Run."""
        ...

    @expose("/clear", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    @provide_session
    def clear(
        self, *, session: Session = ...
    ):  # -> flask.wrappers.Response | werkzeug.wrappers.response.Response | Markup | str:
        """Clear DAG tasks."""
        ...

    @expose("/dagrun_clear", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    @provide_session
    def dagrun_clear(
        self, *, session: Session = ...
    ):  # -> flask.wrappers.Response | werkzeug.wrappers.response.Response | Markup | str:
        """Clear the DagRun."""
        ...

    @expose("/blocked", methods=["POST"])
    @auth.has_access_dag("GET", DagAccessEntity.RUN)
    @provide_session
    def blocked(self, session: Session = ...):  # -> Response:
        """Retrieve active_dag_runs and max_active_runs information for running Dags."""
        ...

    @expose("/dagrun_failed", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.RUN)
    @action_logging
    def dagrun_failed(self):  # -> dict[str, str] | Markup:
        """Mark DagRun failed."""
        ...

    @expose("/dagrun_success", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.RUN)
    @action_logging
    def dagrun_success(self):  # -> dict[str, str] | Markup:
        """Mark DagRun success."""
        ...

    @expose("/dagrun_queued", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.RUN)
    @action_logging
    def dagrun_queued(self):  # -> dict[str, str] | Markup:
        """Queue DagRun so tasks that haven't run yet can be started."""
        ...

    @expose("/dagrun_details")
    def dagrun_details(self):  # -> Response:
        """Redirect to the Grid DagRun page. This is avoids breaking links."""
        ...

    @expose("/confirm", methods=["GET"])
    @auth.has_access_dag("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def confirm(
        self,
    ):  # -> flask.wrappers.Response | werkzeug.wrappers.response.Response | Markup | str:
        """Show confirmation page for marking tasks as success or failed."""
        ...

    @expose("/failed", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def failed(self):  # -> Response | None:
        """Mark task or task_group as failed."""
        ...

    @expose("/success", methods=["POST"])
    @auth.has_access_dag("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def success(self):  # -> Response | None:
        """Mark task or task_group as success."""
        ...

    @expose("/dags/<string:dag_id>")
    def dag(self, dag_id):  # -> Response:
        """Redirect to default DAG view."""
        ...

    @expose("/tree")
    def legacy_tree(self):  # -> Response:
        """Redirect to the replacement - grid view. Kept for backwards compatibility."""
        ...

    @expose("/dags/<string:dag_id>/grid")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @gzipped
    @provide_session
    def grid(self, dag_id: str, session: Session = ...):  # -> Response | str:
        """Get Dag's grid view."""
        ...

    @expose("/calendar")
    def legacy_calendar(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/calendar")
    def calendar(self, dag_id: str):  # -> Response:
        """Redirect to the replacement - grid + calendar. Kept for backwards compatibility."""
        ...

    @expose("/object/calendar_data")
    @auth.has_access_dag("GET", DagAccessEntity.RUN)
    @gzipped
    @provide_session
    def calendar_data(
        self, session: Session = ...
    ):  # -> tuple[dict[str, str], Literal[404]] | tuple[Markup, dict[str, str]]:
        """Get DAG runs as calendar."""
        ...

    @expose("/graph")
    def legacy_graph(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/graph")
    @gzipped
    @provide_session
    def graph(self, dag_id: str, session: Session = ...):  # -> Response:
        """Redirect to the replacement - grid + graph. Kept for backwards compatibility."""
        ...

    @expose("/duration")
    def legacy_duration(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/duration")
    def duration(self, dag_id: str):  # -> Response:
        """Redirect to Grid view."""
        ...

    @expose("/tries")
    def legacy_tries(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/tries")
    def tries(self, dag_id: str):  # -> Response:
        """Redirect to grid view."""
        ...

    @expose("/landing_times")
    def legacy_landing_times(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/landing-times")
    def landing_times(self, dag_id: str):  # -> Response:
        """Redirect to run duration page."""
        ...

    @expose("/paused", methods=["POST"])
    @auth.has_access_dag("PUT")
    @action_logging
    def paused(self):  # -> Literal['OK']:
        """Toggle paused."""
        ...

    @expose("/gantt")
    def legacy_gantt(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/gantt")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def gantt(self, dag_id: str, session: Session = ...):  # -> Response:
        """Redirect to the replacement - grid + gantt. Kept for backwards compatibility."""
        ...

    @expose("/extra_links")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    def extra_links(
        self, *, session: Session = ...
    ):  # -> tuple[dict[str, Any], Literal[404]] | tuple[dict[str, Any], Literal[400]] | dict[str, Any]:
        """
        Return external links for a given Operator.

        It queries the operator that sent the request for the links it wishes
        to provide for a given external link name.

        API: GET
        Args: dag_id: The id of the dag containing the task in question
              task_id: The id of the task in question
              execution_date: The date of execution of the task
              link_name: The name of the link reference to find the actual URL for

        Returns:
            200: {url: <url of link>, error: None} - returned when there was no problem
                finding the URL
            404: {url: None, error: <error message>} - returned when the operator does
                not return a URL
        """
        ...

    @expose("/object/graph_data")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    @gzipped
    def graph_data(self):  # -> tuple[Markup, dict[str, str]]:
        """Get Graph Data."""
        ...

    @expose("/object/task_instances")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    def task_instances(self):  # -> tuple[dict[str, str], Literal[400]] | Response:
        """Show task instances."""
        ...

    @expose("/object/grid_data")
    @auth.has_access_dag("GET", DagAccessEntity.TASK_INSTANCE)
    def grid_data(
        self,
    ):  # -> tuple[dict[str, str], Literal[404]] | tuple[Markup, dict[str, str]]:
        """Return grid data."""
        ...

    @expose("/object/historical_metrics_data")
    @auth.has_access_view(AccessView.CLUSTER_ACTIVITY)
    def historical_metrics_data(self):  # -> tuple[Markup, dict[str, str]]:
        """Return cluster activity historical metrics."""
        ...

    @expose("/object/next_run_datasets/<string:dag_id>")
    @auth.has_access_dag("GET", DagAccessEntity.RUN)
    @auth.has_access_dataset("GET")
    def next_run_datasets(
        self, dag_id
    ):  # -> tuple[dict[str, str], Literal[404]] | tuple[Markup, dict[str, str]]:
        """Return datasets necessary, and their status, for the next dag run."""
        ...

    @expose("/object/dataset_dependencies")
    @auth.has_access_dag("GET", DagAccessEntity.DEPENDENCIES)
    def dataset_dependencies(self):  # -> tuple[Markup, dict[str, str]]:
        """Return dataset dependencies graph."""
        ...

    @expose("/object/datasets_summary")
    @auth.has_access_dataset("GET")
    def datasets_summary(
        self,
    ):  # -> tuple[dict[str, str], Literal[400]] | tuple[Markup, dict[str, str]]:
        """
        Get a summary of datasets.

        Includes the datetime they were last updated and how many updates they've ever had.
        """
        ...

    @expose("/robots.txt")
    @action_logging
    def robots(self):  # -> Response:
        """
        Return a robots.txt file for blocking certain search engine crawlers.

        This mitigates some of the risk associated with exposing Airflow to the public
        internet, however it does not address the real security risks associated with
        such a deployment.
        """
        ...

    @expose("/audit_log")
    def legacy_audit_log(self):  # -> Response:
        """Redirect from url param."""
        ...

    @expose("/dags/<string:dag_id>/audit_log")
    def audit_log(self, dag_id: str):  # -> Response:
        ...
    @expose("/parseDagFile/<string:file_token>")
    def parse_dag(self, file_token: str):  # -> Response:
        ...

class ConfigurationView(AirflowBaseView):
    """View to show Airflow Configurations."""

    default_view = ...
    class_permission_name = ...
    base_permissions = ...
    @expose("/configuration")
    @auth.has_access_configuration("GET")
    def conf(self):  # -> Response | str:
        """Show configuration."""
        ...

class RedocView(AirflowBaseView):
    """Redoc Open API documentation."""

    default_view = ...
    @expose("/redoc")
    def redoc(self):  # -> str:
        """Redoc API documentation."""
        ...

class DagFilter(BaseFilter):
    """Filter using DagIDs."""

    def apply(self, query, func): ...

class AirflowModelView(ModelView):
    """
    Airflow Model View.

    Overridden `__getattribute__` to wraps REST methods with action_logger
    """

    list_widget = AirflowModelListWidget
    page_size = ...
    CustomSQLAInterface = wwwutils.CustomSQLAInterface
    def __getattribute__(self, attr):  # -> Callable[..., object] | Any:
        """
        Wrap action REST methods with `action_logging` wrapper.

        Overriding enables differentiating resource and generation of event name at the decorator level.

        if attr in ["show", "list", "read", "get", "get_list"]:
            return action_logging(event="RESOURCE_NAME"."action_name")(attr)
        else:
            return attr
        """
        ...

    @expose("/show/<pk>", methods=["GET"])
    @auth.has_access_with_pk
    def show(self, pk):  # -> str:
        """
        Show view.

        Same implementation as
        https://github.com/dpgaspar/Flask-AppBuilder/blob/1c3af9b665ed9a3daf36673fee3327d0abf43e5b/flask_appbuilder/views.py#L566

        Override it to use a custom ``has_access_with_pk`` decorator to take into consideration resource for
        fined-grained access.
        """
        ...

    @expose("/edit/<pk>", methods=["GET", "POST"])
    @auth.has_access_with_pk
    def edit(self, pk):  # -> Response | str:
        """
        Edit view.

        Same implementation as
        https://github.com/dpgaspar/Flask-AppBuilder/blob/1c3af9b665ed9a3daf36673fee3327d0abf43e5b/flask_appbuilder/views.py#L602

        Override it to use a custom ``has_access_with_pk`` decorator to take into consideration resource for
        fined-grained access.
        """
        ...

    @expose("/delete/<pk>", methods=["GET", "POST"])
    @auth.has_access_with_pk
    def delete(self, pk):  # -> Response:
        """
        Delete view.

        Same implementation as
        https://github.com/dpgaspar/Flask-AppBuilder/blob/1c3af9b665ed9a3daf36673fee3327d0abf43e5b/flask_appbuilder/views.py#L623

        Override it to use a custom ``has_access_with_pk`` decorator to take into consideration resource for
        fined-grained access.
        """
        ...

    @expose("/action_post", methods=["POST"])
    def action_post(self):
        """
        Handle multiple records selected from a list view.

        Same implementation as
        https://github.com/dpgaspar/Flask-AppBuilder/blob/2c5763371b81cd679d88b9971ba5d1fc4d71d54b/flask_appbuilder/views.py#L677

        The difference is, it no longer check permissions with ``self.appbuilder.sm.has_access``,
        it executes the function without verifying permissions.
        Thus, each action need to be annotated individually with ``@auth.has_access_*`` to check user
        permissions.
        """
        ...

class SlaMissModelView(AirflowModelView):
    """View to show SlaMiss table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(SlaMiss)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    label_columns = ...
    add_columns = ...
    edit_columns = ...
    search_columns = ...
    base_order = ...
    base_filters = ...
    formatters_columns = ...
    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_dag_entities("DELETE", DagAccessEntity.SLA_MISS)
    def action_muldelete(self, items):  # -> Response:
        """Multiple delete action."""
        ...

    @action(
        "mulnotificationsent",
        "Set notification sent to true",
        "Are you sure you want to set all these notifications to sent?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.SLA_MISS)
    def action_mulnotificationsent(self, items: list[SlaMiss]):  # -> Response:
        ...
    @action(
        "mulnotificationsentfalse",
        "Set notification sent to false",
        "Are you sure you want to mark these SLA alerts as notification not sent yet?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.SLA_MISS)
    def action_mulnotificationsentfalse(self, items: list[SlaMiss]):  # -> Response:
        ...
    @action(
        "mulemailsent",
        "Set email sent to true",
        "Are you sure you want to mark these SLA alerts as emails were sent?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.SLA_MISS)
    def action_mulemailsent(self, items: list[SlaMiss]):  # -> Response:
        ...
    @action(
        "mulemailsentfalse",
        "Set email sent to false",
        "Are you sure you want to mark these SLA alerts as emails not sent yet?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.SLA_MISS)
    def action_mulemailsentfalse(self, items: list[SlaMiss]):  # -> Response:
        ...

class XComModelView(AirflowModelView):
    """View to show records from XCom table."""

    route_base = ...
    list_title = ...
    datamodel = AirflowModelView.CustomSQLAInterface(XCom)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    search_columns = ...
    list_columns = ...
    base_order = ...
    order_columns = ...
    base_filters = ...
    formatters_columns = ...
    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_dag_entities("DELETE", DagAccessEntity.XCOM)
    def action_muldelete(self, items):  # -> Response:
        """Multiple delete action."""
        ...

    def pre_add(self, item):  # -> None:
        """Pre add hook."""
        ...

    def pre_update(self, item):  # -> None:
        """Pre update hook."""
        ...

class ConnectionFormWidget(FormWidget):
    """Form widget used to display connection."""

    @cached_property
    def field_behaviours(self) -> str: ...
    @cached_property
    def testable_connection_types(self) -> list[str]: ...

class ConnectionFormProxy:
    """
    A stand-in for the connection form class.

    Flask-Appbuilder model views only ever call the ``refresh()`` function on
    the form class, so this is the perfect place to make the form generation
    dynamic. See docstring of ``create_connection_form_class`` for rationales.
    """

    @staticmethod
    def refresh(obj=...):  # -> DynamicForm:
        ...

class ConnectionModelView(AirflowModelView):
    """View to show records from Connections table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(Connection)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    _edit_columns = ...
    edit_form = add_form = ConnectionFormProxy
    add_template = ...
    edit_template = ...
    add_widget = ConnectionFormWidget
    edit_widget = ConnectionFormWidget
    base_order = ...
    @property
    def add_columns(self) -> list[str]:
        """
        A list of columns to show in the Add form.

        This dynamically calculates additional fields from providers and add
        them to the backing list. This calculation is done exactly once (by
        checking we're referencing the class-level variable instead of the
        instance-level), and only after we enter the request context (to skip
        superfuluous checks done by Flask-Appbuilder on startup).
        """
        ...

    @property
    def edit_columns(self) -> list[str]:
        """
        A list of columns to show in the Edit form.

        This dynamically calculates additional fields from providers and add
        them to the backing list. This calculation is done exactly once (by
        checking we're referencing the class-level variable instead of the
        instance-level), and only after we enter the request context (to skip
        superfuluous checks done by Flask-Appbuilder on startup).
        """
        ...

    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_connection("DELETE")
    def action_muldelete(self, connections):  # -> Response:
        """Multiple delete."""
        ...

    @action(
        "mulduplicate",
        "Duplicate",
        "Are you sure you want to duplicate the selected connections?",
        single=False,
    )
    @provide_session
    @auth.has_access_connection("POST")
    @auth.has_access_connection("GET")
    def action_mulduplicate(self, connections, session: Session = ...):  # -> Response:
        """Duplicate Multiple connections."""
        ...

    def process_form(self, form, is_created):  # -> None:
        """Process form data."""
        ...

    def prefill_form(self, form, pk):  # -> None:
        """Prefill the form."""
        ...

class PluginView(AirflowBaseView):
    """View to show Airflow Plugins."""

    default_view = ...
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    plugins_attributes_to_dump = ...
    @expose("/plugin")
    @auth.has_access_view(AccessView.PLUGINS)
    def list(self):  # -> str:
        """List loaded plugins."""
        ...

class ProviderView(AirflowBaseView):
    """View to show Airflow Providers."""

    default_view = ...
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    @expose("/provider")
    @auth.has_access_view(AccessView.PROVIDERS)
    def list(self):  # -> str:
        """List providers."""
        ...

class PoolModelView(AirflowModelView):
    """View to show records from Pool table."""

    route_base = ...
    list_template = ...
    datamodel = AirflowModelView.CustomSQLAInterface(models.Pool)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    add_columns = ...
    edit_columns = ...
    include_deferred_field = ...
    edit_form_extra_fields = ...
    add_form_extra_fields = ...
    base_order = ...
    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_pool("DELETE")
    def action_muldelete(self, items):  # -> Response:
        """Multiple delete."""
        ...

    @expose("/delete/<pk>", methods=["GET", "POST"])
    @auth.has_access_with_pk
    def delete(self, pk):  # -> Response:
        """Single delete."""
        ...

    def pool_link(self):  # -> Markup:
        """Pool link rendering."""
        ...

    def frunning_slots(self):  # -> Markup:
        """Format running slots rendering."""
        ...

    def fqueued_slots(self):  # -> Markup:
        """Queued slots rendering."""
        ...

    def fscheduled_slots(self):  # -> Markup:
        """Scheduled slots rendering."""
        ...

    def fdeferred_slots(self):  # -> Markup:
        """Deferred slots rendering."""
        ...

    formatters_columns = ...
    validators_columns = ...

class VariableModelView(AirflowModelView):
    """View to show records from Variable table."""

    route_base = ...
    list_template = ...
    edit_template = ...
    show_template = ...
    show_widget = AirflowVariableShowWidget
    datamodel = AirflowModelView.CustomSQLAInterface(models.Variable)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    add_columns = ...
    edit_columns = ...
    show_columns = ...
    search_columns = ...
    base_order = ...
    def hidden_field_formatter(self):  # -> Markup | object | Any:
        """Format hidden fields."""
        ...

    formatters_columns = ...
    validators_columns = ...
    def prefill_form(self, form, request_id):  # -> None:
        ...
    def prefill_show(self, item):  # -> None:
        ...

    extra_args = ...
    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_variable("DELETE")
    def action_muldelete(self, items):  # -> Response:
        """Multiple delete."""
        ...

    @action("varexport", "Export", "", single=False)
    @auth.has_access_variable("GET")
    def action_varexport(self, items):  # -> Response:
        """Export variables."""
        ...

    @expose("/varimport", methods=["POST"])
    @auth.has_access_variable("POST")
    @action_logging(event=f"{permissions.RESOURCE_VARIABLE.lower()}.varimport")
    @provide_session
    def varimport(self, session):  # -> Response:
        """Import variables."""
        ...

class JobModelView(AirflowModelView):
    """View to show records from Job table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(Job)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    search_columns = ...
    base_order = ...
    base_filters = ...
    formatters_columns = ...

class DagRunModelView(AirflowModelView):
    """View to show records from DagRun table."""

    route_base = ...
    datamodel = ...
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    search_columns = ...
    label_columns = ...
    edit_columns = ...
    order_columns = ...
    base_order = ...
    base_filters = ...
    edit_form = DagRunEditForm
    def duration_f(self):  # -> str | None:
        """Duration calculation."""
        ...

    formatters_columns = ...
    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_dag_entities("DELETE", DagAccessEntity.RUN)
    @action_logging
    def action_muldelete(self, items: list[DagRun]):  # -> Response:
        """Multiple delete."""
        ...

    @action("set_queued", "Set state to 'queued'", "", single=False)
    @auth.has_access_dag_entities("PUT", DagAccessEntity.RUN)
    @action_logging
    def action_set_queued(self, drs: list[DagRun]):  # -> Response:
        """Set state to queued."""
        ...

    @action("set_running", "Set state to 'running'", "", single=False)
    @auth.has_access_dag_entities("PUT", DagAccessEntity.RUN)
    @action_logging
    def action_set_running(self, drs: list[DagRun]):  # -> Response:
        """Set state to running."""
        ...

    @action(
        "set_failed",
        "Set state to 'failed'",
        "All running task instances would also be marked as failed, are you sure?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.RUN)
    @provide_session
    @action_logging
    def action_set_failed(
        self, drs: list[DagRun], session: Session = ...
    ):  # -> Response:
        """Set state to failed."""
        ...

    @action(
        "set_success",
        "Set state to 'success'",
        "All task instances would also be marked as success, are you sure?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.RUN)
    @provide_session
    @action_logging
    def action_set_success(
        self, drs: list[DagRun], session: Session = ...
    ):  # -> Response:
        """Set state to success."""
        ...

    @action(
        "clear",
        "Clear the state",
        "All task instances would be cleared, are you sure?",
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.RUN)
    @provide_session
    @action_logging
    def action_clear(self, drs: list[DagRun], session: Session = ...):  # -> Response:
        """Clear the state."""
        ...

class LogModelView(AirflowModelView):
    """View to show records from Log table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(Log)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    search_columns = ...
    label_columns = ...
    base_order = ...
    base_filters = ...
    formatters_columns = ...

class TaskRescheduleModelView(AirflowModelView):
    """View to show records from Task Reschedule table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(models.TaskReschedule)
    related_views = ...
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    label_columns = ...
    search_columns = ...
    base_order = ...
    base_filters = ...
    def duration_f(self):  # -> str | None:
        """Duration calculation."""
        ...

    formatters_columns = ...

class TriggerModelView(AirflowModelView):
    """View to show records from Task Reschedule table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(models.Trigger)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    list_columns = ...
    search_columns = ...
    base_order = ...
    formatters_columns = ...

class TaskInstanceModelView(AirflowModelView):
    """View to show records from TaskInstance table."""

    route_base = ...
    datamodel = AirflowModelView.CustomSQLAInterface(models.TaskInstance)
    class_permission_name = ...
    method_permission_name = ...
    base_permissions = ...
    page_size = ...
    list_columns = ...
    order_columns = ...
    label_columns = ...
    search_columns = ...
    edit_columns = ...
    add_exclude_columns = ...
    edit_form = TaskInstanceEditForm
    base_order = ...
    base_filters = ...
    def log_url_formatter(self):  # -> Markup:
        """Format log URL."""
        ...

    def duration_f(self):  # -> str | None:
        """Format duration."""
        ...

    formatters_columns = ...
    @action(
        "clear",
        lazy_gettext("Clear"),
        lazy_gettext(
            "Are you sure you want to clear the state of the selected task"
            " instance(s) and set their dagruns to the QUEUED state?"
        ),
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    @action_logging
    def action_clear(self, task_instances, session: Session = ...):  # -> Response:
        """Clear an arbitrary number of task instances."""
        ...

    @action(
        "clear_downstream",
        lazy_gettext("Clear (including downstream tasks)"),
        lazy_gettext(
            "Are you sure you want to clear the state of the selected task"
            " instance(s) and all their downstream dependencies, and set their dagruns to the QUEUED state?"
        ),
        single=False,
    )
    @auth.has_access_dag_entities("PUT", DagAccessEntity.TASK_INSTANCE)
    @provide_session
    @action_logging
    def action_clear_downstream(
        self, task_instances, session: Session = ...
    ):  # -> Response:
        """Clear an arbitrary number of task instances, including downstream dependencies."""
        ...

    @action(
        "muldelete",
        "Delete",
        "Are you sure you want to delete selected records?",
        single=False,
    )
    @auth.has_access_dag_entities("DELETE", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def action_muldelete(self, items):  # -> Response:
        ...
    @provide_session
    def set_task_instance_state(
        self,
        tis: Collection[TaskInstance],
        target_state: TaskInstanceState,
        session: Session = ...,
    ) -> None:
        """Set task instance state."""
        ...

    @action("set_failed", "Set state to 'failed'", "", single=False)
    @auth.has_access_dag_entities("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def action_set_failed(self, tis):  # -> Response:
        """Set state to 'failed'."""
        ...

    @action("set_success", "Set state to 'success'", "", single=False)
    @auth.has_access_dag_entities("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def action_set_success(self, tis):  # -> Response:
        """Set state to 'success'."""
        ...

    @action("set_retry", "Set state to 'up_for_retry'", "", single=False)
    @auth.has_access_dag_entities("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def action_set_retry(self, tis):  # -> Response:
        """Set state to 'up_for_retry'."""
        ...

    @action("set_skipped", "Set state to 'skipped'", "", single=False)
    @auth.has_access_dag_entities("PUT", DagAccessEntity.TASK_INSTANCE)
    @action_logging
    def action_set_skipped(self, tis):  # -> Response:
        """Set state to skipped."""
        ...

class AutocompleteView(AirflowBaseView):
    """View to provide autocomplete results."""

    @provide_session
    @expose("/dagmodel/autocomplete")
    def autocomplete(self, session: Session = ...):  # -> Response:
        """Autocomplete."""
        ...

class DagDependenciesView(AirflowBaseView):
    """View to show dependencies between DAGs."""

    refresh_interval = ...
    last_refresh = ...
    nodes: list[dict[str, Any]] = ...
    edges: list[dict[str, str]] = ...
    @expose("/dag-dependencies")
    @auth.has_access_dag("GET", DagAccessEntity.DEPENDENCIES)
    @gzipped
    def list(self):  # -> str:
        """Display DAG dependencies."""
        ...

def add_user_permissions_to_dag(sender, template, context, **extra):  # -> None:
    """
    Add `.can_edit`, `.can_trigger`, and `.can_delete` properties to DAG based on current user's permissions.

    Located in `views.py` rather than the DAG model to keep permissions logic out of the Airflow core.
    """
    ...

def restrict_to_dev(f):  # -> Callable[..., Any]:
    ...

class DevView(BaseView):
    """
    View to show Airflow Dev Endpoints.

    This view should only be accessible in development mode. You can enable development mode by setting
    `AIRFLOW_ENV=development` in your environment.

    :meta private:
    """

    route_base = ...
    @expose("/coverage/<path:path>")
    @restrict_to_dev
    def coverage(self, path):  # -> Response:
        ...

class DocsView(BaseView):
    """
    View to show airflow dev docs endpoints.

    This view should only be accessible in development mode. You can enable development mode by setting
    `AIRFLOW_ENV=development` in your environment.
    """

    route_base = ...
    @expose("/")
    @expose("/<path:filename>")
    @restrict_to_dev
    def home(self, filename=...):  # -> Response:
        """Serve documentation from the build directory."""
        ...
