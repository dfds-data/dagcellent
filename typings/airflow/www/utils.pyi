"""
This type stub file was generated by pyright.
"""

import json
from collections.abc import Callable, Sequence
from typing import TYPE_CHECKING, Any

from airflow.models.dagrun import DagRun
from airflow.models.taskinstance import TaskInstance
from airflow.utils.state import TaskInstanceState
from airflow.www.extensions.init_appbuilder import AirflowAppBuilder
from flask_appbuilder.models.filters import BaseFilter
from flask_appbuilder.models.sqla import Model, filters as fab_sqlafilters
from flask_appbuilder.models.sqla.interface import SQLAInterface
from markupsafe import Markup
from pendulum.datetime import DateTime
from pygments.lexer import Lexer
from sqlalchemy.orm.session import Session
from sqlalchemy.sql import Select

if TYPE_CHECKING: ...
TI = TaskInstance
logger = ...

def datetime_to_string(value: DateTime | None) -> str | None: ...
def get_mapped_instances(task_instance, session): ...
def get_instance_with_map(
    task_instance, session
):  # -> dict[Any, Any] | dict[str, Any] | None:
    ...

priority: list[None | TaskInstanceState] = ...

def get_mapped_summary(parent_instance, task_instances):  # -> dict[str, Any]:
    ...
def get_dag_run_conf(
    dag_run_conf: Any, *, json_encoder: type[json.JSONEncoder] = ...
) -> tuple[str | None, bool]: ...
def encode_dag_run(
    dag_run: DagRun | None, *, json_encoder: type[json.JSONEncoder] = ...
) -> tuple[dict[str, Any] | None, None | str]: ...
def check_import_errors(fileloc, session):  # -> None:
    ...
def check_dag_warnings(dag_id, session):  # -> None:
    ...
def get_sensitive_variables_fields():  # -> frozenset[str]:
    ...
def should_hide_value_for_key(key_name):  # -> bool:
    ...
def get_params(**kwargs):  # -> str:
    """Return URL-encoded params."""
    ...

def generate_pages(
    current_page,
    num_of_pages,
    search=...,
    status=...,
    tags=...,
    window=...,
    sorting_key=...,
    sorting_direction=...,
):  # -> Markup:
    """
    Generate the HTML for a paging component.

    Uses a similar logic to the paging auto-generated by Flask managed views. The paging
    component defines a number of pages visible in the pager (window) and once the user
    goes to a page beyond the largest visible, it would scroll to the right the page numbers
    and keeps the current one in the middle of the pager component. When in the last pages,
    the pages won't scroll and just keep moving until the last page. Pager also contains
    <first, previous, ..., next, last> pages.
    This component takes into account custom parameters such as search, status, and tags
    which could be added to the pages link in order to maintain the state between
    client and server. It also allows to make a bookmark on a specific paging state.

    :param current_page: the current page number, 0-indexed
    :param num_of_pages: the total number of pages
    :param search: the search query string, if any
    :param status: 'all', 'active', or 'paused'
    :param tags: array of strings of the current filtered tags
    :param window: the number of pages to be shown in the paging component (7 default)
    :param sorting_key: the sorting key selected for dags, None indicates that sorting is not needed/provided
    :param sorting_direction: direction of sorting, 'asc' or 'desc',
    None indicates that sorting is not needed/provided
    :return: the HTML string of the paging component
    """
    ...

def epoch(dttm):  # -> tuple[int]:
    """Return an epoch-type date (tuple with no timezone)."""
    ...

def make_cache_key(*args, **kwargs):  # -> bytes:
    """Get a unique key per URL; used by cache."""
    ...

def task_instance_link(attr):  # -> Markup:
    """Generate a URL to the Graph view for a TaskInstance."""
    ...

def state_token(state):  # -> Markup:
    """Return a formatted string with HTML for a given State."""
    ...

def state_f(attr):  # -> Markup:
    """Get 'state' & return a formatted string with HTML for a given State."""
    ...

def nobr_f(attr_name):  # -> Callable[..., Markup]:
    """Return a formatted string with HTML with a Non-breaking Text element."""
    ...

def datetime_f(attr_name):  # -> Callable[..., str]:
    """Return a formatted string with HTML for given DataTime."""
    ...

def datetime_html(dttm: DateTime | None) -> str:
    """Return an HTML formatted string with time element to support timezone changes in UI."""
    ...

def json_f(attr_name):  # -> Callable[..., Markup]:
    """Return a formatted string with HTML for given JSON serializable."""
    ...

def dag_link(attr):  # -> Markup:
    """Generate a URL to the Graph view for a Dag."""
    ...

def dag_run_link(attr):  # -> Markup:
    """Generate a URL to the Graph view for a DagRun."""
    ...

def sorted_dag_runs(
    query: Select, *, ordering: Sequence[str], limit: int, session: Session
) -> Sequence[DagRun]:
    """
    Produce DAG runs sorted by specified columns.

    :param query: An ORM select object against *DagRun*.
    :param ordering: Column names to sort the runs. should generally come from a
        timetable's ``run_ordering``.
    :param limit: Number of runs to limit to.
    :param session: SQLAlchemy ORM session object
    :return: A list of DagRun objects ordered by the specified columns. The list
        contains only the *last* objects, but in *ascending* order.
    """
    ...

def format_map_index(attr: dict) -> str:
    """Format map index for list columns in model view."""
    ...

def pygment_html_render(s, lexer=...):
    """Highlight text using a given Lexer."""
    ...

def render(
    obj: Any, lexer: Lexer, handler: Callable[[Any], str] | None = ...
):  # -> Markup | str:
    """Render a given Python object with a given Pygments lexer."""
    ...

def json_render(obj, lexer):  # -> Markup | Literal['']:
    """Render a given Python object with json lexer."""
    ...

def wrapped_markdown(s, css_class=...):  # -> Markup | None:
    """Convert a Markdown string to HTML."""
    ...

def get_attr_renderer():  # -> dict[str, Any]:
    """Return Dictionary containing different Pygments Lexers for Rendering & Highlighting."""
    ...

class UtcAwareFilterMixin:
    """Mixin for filter for UTC time."""

    def apply(self, query, value):
        """Apply the filter."""
        ...

class FilterIsNull(BaseFilter):
    """Is null filter."""

    name = ...
    arg_name = ...
    def apply(self, query, value): ...

class FilterIsNotNull(BaseFilter):
    """Is not null filter."""

    name = ...
    arg_name = ...
    def apply(self, query, value): ...

class FilterGreaterOrEqual(BaseFilter):
    """Greater than or Equal filter."""

    name = ...
    arg_name = ...
    def apply(self, query, value): ...

class FilterSmallerOrEqual(BaseFilter):
    """Smaller than or Equal filter."""

    name = ...
    arg_name = ...
    def apply(self, query, value): ...

class UtcAwareFilterSmallerOrEqual(UtcAwareFilterMixin, FilterSmallerOrEqual):
    """Smaller than or Equal filter for UTC time."""

    ...

class UtcAwareFilterGreaterOrEqual(UtcAwareFilterMixin, FilterGreaterOrEqual):
    """Greater than or Equal filter for UTC time."""

    ...

class UtcAwareFilterEqual(UtcAwareFilterMixin, fab_sqlafilters.FilterEqual):
    """Equality filter for UTC time."""

    ...

class UtcAwareFilterGreater(UtcAwareFilterMixin, fab_sqlafilters.FilterGreater):
    """Greater Than filter for UTC time."""

    ...

class UtcAwareFilterSmaller(UtcAwareFilterMixin, fab_sqlafilters.FilterSmaller):
    """Smaller Than filter for UTC time."""

    ...

class UtcAwareFilterNotEqual(UtcAwareFilterMixin, fab_sqlafilters.FilterNotEqual):
    """Not Equal To filter for UTC time."""

    ...

class UtcAwareFilterConverter(fab_sqlafilters.SQLAFilterConverter):
    """Retrieve conversion tables for UTC-Aware filters."""

    ...

class AirflowFilterConverter(fab_sqlafilters.SQLAFilterConverter):
    """Retrieve conversion tables for Airflow-specific filters."""

    conversion_table = ...
    def __init__(self, datamodel) -> None: ...

class CustomSQLAInterface(SQLAInterface):
    """
    FAB does not know how to handle columns with leading underscores because they are not supported by WTForm.

    This hack will remove the leading '_' from the key to lookup the column names.
    """

    def __init__(self, obj, session: Session | None = ...) -> None: ...
    def is_utcdatetime(self, col_name):  # -> bool:
        """Check if the datetime is a UTC one."""
        ...

    def is_extendedjson(self, col_name):  # -> bool:
        """Check if it is a special extended JSON type."""
        ...

    def get_col_default(self, col_name: str) -> Any: ...

    filter_converter_class = AirflowFilterConverter

class DagRunCustomSQLAInterface(CustomSQLAInterface):
    """
    Custom interface to allow faster deletion.

    The ``delete`` and ``delete_all`` methods are overridden to speed up
    deletion when a DAG run has a lot of related task instances. Relying on
    SQLAlchemy's cascading deletion is comparatively slow in this situation.
    """

    def delete(self, item: Model, raise_exception: bool = ...) -> bool: ...
    def delete_all(self, items: list[Model]) -> bool: ...

class UIAlert:
    """
    Helper for alerts messages shown on the UI.

    :param message: The message to display, either a string or Markup
    :param category: The category of the message, one of "info", "warning", "error", or any custom category.
        Defaults to "info".
    :param roles: List of roles that should be shown the message. If ``None``, show to all users.
    :param html: Whether the message has safe html markup in it. Defaults to False.


    For example, show a message to all users:

    .. code-block:: python

        UIAlert("Welcome to Airflow")

    Or only for users with the User role:

    .. code-block:: python

        UIAlert("Airflow update happening next week", roles=["User"])

    You can also pass html in the message:

    .. code-block:: python

        UIAlert(
            'Visit <a href="https://airflow.apache.org">airflow.apache.org</a>',
            html=True,
        )

        # or safely escape part of the message
        # (more details: https://markupsafe.palletsprojects.com/en/2.0.x/formatting/)
        UIAlert(Markup("Welcome <em>%s</em>") % ("John & Jane Doe",))
    """

    def __init__(
        self,
        message: str | Markup,
        category: str = ...,
        roles: list[str] | None = ...,
        html: bool = ...,
    ) -> None: ...
    def should_show(self, appbuilder: AirflowAppBuilder) -> bool:
        """
        Determine if the user should see the message.

        The decision is based on the user's role. If ``AUTH_ROLE_PUBLIC`` is
        set in ``webserver_config.py``, An anonymous user would have the
        ``AUTH_ROLE_PUBLIC`` role.
        """
        ...
