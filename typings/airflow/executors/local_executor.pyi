"""
This type stub file was generated by pyright.
"""

from abc import abstractmethod
from multiprocessing import Process
from queue import Queue
from typing import TYPE_CHECKING, Any

from airflow.executors.base_executor import BaseExecutor, CommandType
from airflow.models.taskinstance import TaskInstanceStateType
from airflow.models.taskinstancekey import TaskInstanceKey
from airflow.traces.tracer import span
from airflow.utils.log.logging_mixin import LoggingMixin

"""
LocalExecutor.

.. seealso::
    For more information on how the LocalExecutor works, take a look at the guide:
    :ref:`executor:LocalExecutor`
"""
if TYPE_CHECKING:
    ExecutorWorkType = tuple[TaskInstanceKey | None, CommandType | None]

class LocalWorkerBase(Process, LoggingMixin):
    """
    LocalWorkerBase implementation to run airflow commands.

    Executes the given command and puts the result into a result queue when done, terminating execution.

    :param result_queue: the queue to store result state
    """

    def __init__(self, result_queue: Queue[TaskInstanceStateType]) -> None: ...
    def run(self):  # -> None:
        ...
    @span
    def execute_work(self, key: TaskInstanceKey, command: CommandType) -> None:
        """
        Execute command received and stores result state in queue.

        :param key: the key to identify the task instance
        :param command: the command to execute
        """
        ...

    @abstractmethod
    def do_work(self):
        """Execute tasks; called in the subprocess."""
        ...

class LocalWorker(LocalWorkerBase):
    """
    Local worker that executes the task.

    :param result_queue: queue where results of the tasks are put.
    :param key: key identifying task instance
    :param command: Command to execute
    """

    def __init__(
        self,
        result_queue: Queue[TaskInstanceStateType],
        key: TaskInstanceKey,
        command: CommandType,
    ) -> None: ...
    @span
    def do_work(self) -> None: ...

class QueuedLocalWorker(LocalWorkerBase):
    """
    LocalWorker implementation that is waiting for tasks from a queue.

    Will continue executing commands as they become available in the queue.
    It will terminate execution once the poison token is found.

    :param task_queue: queue from which worker reads tasks
    :param result_queue: queue where worker puts results after finishing tasks
    """

    def __init__(
        self,
        task_queue: Queue[ExecutorWorkType],
        result_queue: Queue[TaskInstanceStateType],
    ) -> None: ...
    @span
    def do_work(self) -> None: ...

class LocalExecutor(BaseExecutor):
    """
    LocalExecutor executes tasks locally in parallel.

    It uses the multiprocessing Python library and queues to parallelize the execution of tasks.

    :param parallelism: how many parallel processes are run in the executor
    """

    is_local: bool = ...
    supports_pickling: bool = ...
    serve_logs: bool = ...
    def __init__(self, parallelism: int = ...) -> None: ...

    class UnlimitedParallelism:
        """
        Implement LocalExecutor with unlimited parallelism, starting one process per command executed.

        :param executor: the executor instance to implement.
        """

        def __init__(self, executor: LocalExecutor) -> None: ...
        def start(self) -> None:
            """Start the executor."""
            ...

        @span
        def execute_async(
            self,
            key: TaskInstanceKey,
            command: CommandType,
            queue: str | None = ...,
            executor_config: Any | None = ...,
        ) -> None:
            """
            Execute task asynchronously.

            :param key: the key to identify the task instance
            :param command: the command to execute
            :param queue: Name of the queue
            :param executor_config: configuration for the executor
            """
            ...

        def sync(self) -> None:
            """Sync will get called periodically by the heartbeat method."""
            ...

        def end(self) -> None:
            """Wait synchronously for the previously submitted job to complete."""
            ...

    class LimitedParallelism:
        """
        Implements LocalExecutor with limited parallelism.

        Uses a task queue to coordinate work distribution.

        :param executor: the executor instance to implement.
        """

        def __init__(self, executor: LocalExecutor) -> None: ...
        def start(self) -> None:
            """Start limited parallelism implementation."""
            ...

        @span
        def execute_async(
            self,
            key: TaskInstanceKey,
            command: CommandType,
            queue: str | None = ...,
            executor_config: Any | None = ...,
        ) -> None:
            """
            Execute task asynchronously.

            :param key: the key to identify the task instance
            :param command: the command to execute
            :param queue: name of the queue
            :param executor_config: configuration for the executor
            """
            ...

        def sync(self):  # -> None:
            """Sync will get called periodically by the heartbeat method."""
            ...

        def end(self):  # -> None:
            """
            End the executor.

            Sends the poison pill to all workers.
            """
            ...

    def start(self) -> None:
        """Start the executor."""
        ...

    @span
    def execute_async(
        self,
        key: TaskInstanceKey,
        command: CommandType,
        queue: str | None = ...,
        executor_config: Any | None = ...,
    ) -> None:
        """Execute asynchronously."""
        ...

    def sync(self) -> None:
        """Sync will get called periodically by the heartbeat method."""
        ...

    def end(self) -> None:
        """End the executor."""
        ...

    def terminate(self):  # -> None:
        """Terminate the executor is not doing anything."""
        ...
