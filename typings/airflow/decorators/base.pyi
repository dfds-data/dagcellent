"""
This type stub file was generated by pyright.
"""

import inspect
from collections.abc import Callable, Collection, Mapping, Sequence
from functools import cached_property
from typing import (
    TYPE_CHECKING,
    Any,
    ClassVar,
    Generic,
    TypeVar,
    overload,
)

import attr
from airflow.models.baseoperator import BaseOperator
from airflow.models.dag import DAG
from airflow.models.expandinput import (
    ExpandInput,
    OperatorExpandArgument,
    OperatorExpandKwargsArgument,
)
from airflow.models.mappedoperator import MappedOperator
from airflow.models.xcom_arg import XComArg
from airflow.typing_compat import ParamSpec, Protocol
from airflow.utils.context import Context
from airflow.utils.task_group import TaskGroup

if TYPE_CHECKING: ...

class ExpandableFactory(Protocol):
    """
    Protocol providing inspection against wrapped function.

    This is used in ``validate_expand_kwargs`` and implemented by function
    decorators like ``@task`` and ``@task_group``.

    :meta private:
    """

    function: Callable
    @cached_property
    def function_signature(self) -> inspect.Signature: ...

def get_unique_task_id(
    task_id: str, dag: DAG | None = ..., task_group: TaskGroup | None = ...
) -> str:
    """
    Generate unique task id given a DAG (or if run in a DAG context).

    IDs are generated by appending a unique number to the end of
    the original task id.

    Example:
      task_id
      task_id__1
      task_id__2
      ...
      task_id__20
    """
    ...

class DecoratedOperator(BaseOperator):
    """
    Wraps a Python callable and captures args/kwargs when called for execution.

    :param python_callable: A reference to an object that is callable
    :param op_kwargs: a dictionary of keyword arguments that will get unpacked
        in your function (templated)
    :param op_args: a list of positional arguments that will get unpacked when
        calling your callable (templated)
    :param multiple_outputs: If set to True, the decorated function's return value will be unrolled to
        multiple XCom values. Dict will unroll to XCom values with its keys as XCom keys. Defaults to False.
    :param kwargs_to_upstream: For certain operators, we might need to upstream certain arguments
        that would otherwise be absorbed by the DecoratedOperator (for example python_callable for the
        PythonOperator). This gives a user the option to upstream kwargs as needed.
    """

    template_fields: Sequence[str] = ...
    template_fields_renderers = ...
    shallow_copy_attrs: Sequence[str] = ...
    def __init__(
        self,
        *,
        python_callable: Callable,
        task_id: str,
        op_args: Collection[Any] | None = ...,
        op_kwargs: Mapping[str, Any] | None = ...,
        kwargs_to_upstream: dict[str, Any] | None = ...,
        **kwargs,
    ) -> None: ...
    def execute(self, context: Context):  # -> list[Any] | Dataset | Any:
        ...
    def get_python_source(self):  # -> str:
        ...

FParams = ParamSpec("FParams")
FReturn = TypeVar("FReturn")
OperatorSubclass = TypeVar("OperatorSubclass", bound="BaseOperator")

@attr.define(slots=False)
class _TaskDecorator(ExpandableFactory, Generic[FParams, FReturn, OperatorSubclass]):
    """
    Helper class for providing dynamic task mapping to decorated functions.

    ``task_decorator_factory`` returns an instance of this, instead of just a plain wrapped function.

    :meta private:
    """

    function: Callable[FParams, FReturn] = ...
    operator_class: type[OperatorSubclass]
    multiple_outputs: bool = ...
    kwargs: dict[str, Any] = ...
    decorator_name: str = ...
    _airflow_is_task_decorator: ClassVar[bool] = ...
    is_setup: bool = ...
    is_teardown: bool = ...
    on_failure_fail_dagrun: bool = ...
    def __attrs_post_init__(self):  # -> None:
        ...
    def __call__(self, *args: FParams.args, **kwargs: FParams.kwargs) -> XComArg: ...
    @property
    def __wrapped__(self) -> Callable[FParams, FReturn]: ...
    def expand(self, **map_kwargs: OperatorExpandArgument) -> XComArg: ...
    def expand_kwargs(
        self, kwargs: OperatorExpandKwargsArgument, *, strict: bool = ...
    ) -> XComArg: ...
    def partial(
        self, **kwargs: Any
    ) -> _TaskDecorator[FParams, FReturn, OperatorSubclass]: ...
    def override(
        self, **kwargs: Any
    ) -> _TaskDecorator[FParams, FReturn, OperatorSubclass]: ...

@attr.define(kw_only=True, repr=False)
class DecoratedMappedOperator(MappedOperator):
    """MappedOperator implementation for @task-decorated task function."""

    multiple_outputs: bool
    python_callable: Callable
    op_kwargs_expand_input: ExpandInput
    def __hash__(self) -> int: ...
    def __attrs_post_init__(self):  # -> None:
        ...

class Task(Protocol, Generic[FParams, FReturn]):
    """
    Declaration of a @task-decorated callable for type-checking.

    An instance of this type inherits the call signature of the decorated
    function wrapped in it (not *exactly* since it actually returns an XComArg,
    but there's no way to express that right now), and provides two additional
    methods for task-mapping.

    This type is implemented by ``_TaskDecorator`` at runtime.
    """

    __call__: Callable[FParams, XComArg]
    function: Callable[FParams, FReturn]
    @property
    def __wrapped__(self) -> Callable[FParams, FReturn]: ...
    def partial(self, **kwargs: Any) -> Task[FParams, FReturn]: ...
    def expand(self, **kwargs: OperatorExpandArgument) -> XComArg: ...
    def expand_kwargs(
        self, kwargs: OperatorExpandKwargsArgument, *, strict: bool = ...
    ) -> XComArg: ...
    def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...

class TaskDecorator(Protocol):
    """Type declaration for ``task_decorator_factory`` return type."""

    @overload
    def __call__(
        self, python_callable: Callable[FParams, FReturn]
    ) -> Task[FParams, FReturn]:
        """For the "bare decorator" ``@task`` case."""
        ...

    @overload
    def __call__(
        self, *, multiple_outputs: bool | None = ..., **kwargs: Any
    ) -> Callable[[Callable[FParams, FReturn]], Task[FParams, FReturn]]:
        """For the decorator factory ``@task()`` case."""
        ...

    def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...

def task_decorator_factory(
    python_callable: Callable | None = ...,
    *,
    multiple_outputs: bool | None = ...,
    decorated_operator_class: type[BaseOperator],
    **kwargs,
) -> TaskDecorator:
    """
    Generate a wrapper that wraps a function into an Airflow operator.

    Can be reused in a single DAG.

    :param python_callable: Function to decorate.
    :param multiple_outputs: If set to True, the decorated function's return
        value will be unrolled to multiple XCom values. Dict will unroll to XCom
        values with its keys as XCom keys. If set to False (default), only at
        most one XCom value is pushed.
    :param decorated_operator_class: The operator that executes the logic needed
        to run the python function in the correct environment.

    Other kwargs are directly forwarded to the underlying operator class when
    it's instantiated.
    """
    ...
