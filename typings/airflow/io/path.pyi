"""
This type stub file was generated by pyright.
"""

import typing

from airflow.io.utils.stat import stat_result
from airflow.utils.log.logging_mixin import LoggingMixin
from upath.implementations.cloud import CloudPath

if typing.TYPE_CHECKING: ...
PT = typing.TypeVar("PT", bound="ObjectStoragePath")
default = ...

class TrackingFileWrapper(LoggingMixin):
    """Wrapper that tracks file operations to intercept lineage."""

    def __init__(self, path: ObjectStoragePath, obj) -> None: ...
    def __getattr__(self, name):  # -> Callable[..., object] | Any:
        ...
    def __getitem__(self, key): ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...

class ObjectStoragePath(CloudPath):
    """A path-like object for object storage."""

    __version__: typing.ClassVar[int] = ...
    _protocol_dispatch = ...
    sep: typing.ClassVar[str] = ...
    root_marker: typing.ClassVar[str] = ...
    __slots__ = ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def samestore(self, other: typing.Any) -> bool: ...
    @property
    def container(self) -> str: ...
    @property
    def bucket(self) -> str: ...
    @property
    def key(self) -> str: ...
    @property
    def namespace(self) -> str: ...
    def open(self, mode=..., **kwargs):  # -> TrackingFileWrapper:
        """Open the file pointed to by this path."""
        ...

    def stat(self) -> stat_result:
        """Call ``stat`` and return the result."""
        ...

    def samefile(self, other_path: typing.Any) -> bool:
        """Return whether other_path is the same or not as this file."""
        ...

    def replace(self, target) -> ObjectStoragePath:
        """
        Rename this path to the target path, overwriting if that path exists.

        The target path may be absolute or relative. Relative paths are
        interpreted relative to the current working directory, *not* the
        directory of the Path object.

        Returns the new Path instance pointing to the target path.
        """
        ...

    @classmethod
    def cwd(cls):  # -> UPath:
        ...
    @classmethod
    def home(cls):  # -> UPath:
        ...
    def ukey(self) -> str:
        """Hash of file properties, to tell if it has changed."""
        ...

    def checksum(self) -> int:
        """Return the checksum of the file at this path."""
        ...

    def read_block(self, offset: int, length: int, delimiter=...):  # -> bytes:
        r"""
        Read a block of bytes.

        Starting at ``offset`` of the file, read ``length`` bytes. If
        ``delimiter`` is set then we ensure that the read starts and stops at
        delimiter boundaries that follow the locations ``offset`` and ``offset
        + length``. If ``offset`` is zero then we start at zero. The
        bytestring returned WILL include the end delimiter string.

        If offset+length is beyond the eof, reads to eof.

        :param offset: int
                      Byte offset to start read
        :param length: int
                      Number of bytes to read. If None, read to the end.
        :param delimiter: bytes (optional)
                        Ensure reading starts and stops at delimiter bytestring

        Examples
        --------
        >>> read_block(0, 13)
        b'Alice, 100\\nBo'
        >>> read_block(0, 13, delimiter=b"\\n")
        b'Alice, 100\\nBob, 200\\n'

        Use ``length=None`` to read to the end of the file.
        >>> read_block(0, None, delimiter=b"\\n")
        b'Alice, 100\\nBob, 200\\nCharlie, 300'

        See Also
        --------
        :func:`fsspec.utils.read_block`
        """
        ...

    def sign(self, expiration: int = ..., **kwargs):
        """
        Create a signed URL representing the given path.

        Some implementations allow temporary URLs to be generated, as a
        way of delegating credentials.

        :param path: str
                     The path on the filesystem
        :param expiration: int
                          Number of seconds to enable the URL for (if supported)

        :returns URL: str
                     The signed URL

        :raises NotImplementedError: if the method is not implemented for a store
        """
        ...

    def size(self) -> int:
        """Size in bytes of the file at this path."""
        ...

    def copy(
        self, dst: str | ObjectStoragePath, recursive: bool = ..., **kwargs
    ) -> None:
        """
        Copy file(s) from this path to another location.

        For remote to remote copies, the key used for the destination will be the same as the source.
        So that s3://src_bucket/foo/bar will be copied to gcs://dst_bucket/foo/bar and not
        gcs://dst_bucket/bar.

        :param dst: Destination path
        :param recursive: If True, copy directories recursively.

        kwargs: Additional keyword arguments to be passed to the underlying implementation.
        """
        ...

    def move(
        self, path: str | ObjectStoragePath, recursive: bool = ..., **kwargs
    ) -> None:
        """
        Move file(s) from this path to another location.

        :param path: Destination path
        :param recursive: bool
                         If True, move directories recursively.

        kwargs: Additional keyword arguments to be passed to the underlying implementation.
        """
        ...

    def serialize(self) -> dict[str, typing.Any]: ...
    @classmethod
    def deserialize(cls, data: dict, version: int) -> ObjectStoragePath: ...
    def __str__(self) -> str: ...
