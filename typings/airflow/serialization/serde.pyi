"""
This type stub file was generated by pyright.
"""

from types import ModuleType
from typing import TYPE_CHECKING, Any, TypeVar, Union

if TYPE_CHECKING: ...
log = ...
MAX_RECURSION_DEPTH = ...
CLASSNAME = ...
VERSION = ...
DATA = ...
SCHEMA_ID = ...
CACHE = ...
OLD_TYPE = ...
OLD_SOURCE = ...
OLD_DATA = ...
OLD_DICT = ...
DEFAULT_VERSION = ...
T = TypeVar("T", bool, float, int, dict, list, str, tuple, set)
U = Union[bool, float, int, dict, list, str, tuple, set]
S = Union[list, tuple, set]
_serializers: dict[str, ModuleType] = ...
_deserializers: dict[str, ModuleType] = ...
_stringifiers: dict[str, ModuleType] = ...
_extra_allowed: set[str] = ...
_primitives = ...
_builtin_collections = ...

def encode(cls: str, version: int, data: T) -> dict[str, str | int | T]:
    """Encode an object so it can be understood by the deserializer."""
    ...

def decode(d: dict[str, Any]) -> tuple[str, int, Any]: ...
def serialize(o: object, depth: int = ...) -> U | None:
    """
    Serialize an object into a representation consisting only built-in types.

    Primitives (int, float, bool, str) are returned as-is. Built-in collections
    are iterated over, where it is assumed that keys in a dict can be represented
    as str.

    Values that are not of a built-in type are serialized if a serializer is
    found for them. The order in which serializers are used is

    1. A ``serialize`` function provided by the object.
    2. A registered serializer in the namespace of ``airflow.serialization.serializers``
    3. Annotations from attr or dataclass.

    Limitations: attr and dataclass objects can lose type information for nested objects
    as they do not store this when calling ``asdict``. This means that at deserialization values
    will be deserialized as a dict as opposed to reinstating the object. Provide
    your own serializer to work around this.

    :param o: The object to serialize.
    :param depth: Private tracker for nested serialization.
    :raise TypeError: A serializer cannot be found.
    :raise RecursionError: The object is too nested for the function to handle.
    :return: A representation of ``o`` that consists of only built-in types.
    """
    ...

def deserialize(o: T | None, full=..., type_hint: Any = ...) -> object:
    """
    Deserialize an object of primitive type and uses an allow list to determine if a class can be loaded.

    :param o: primitive to deserialize into an arbitrary object.
    :param full: if False it will return a stringified representation
                 of an object and will not load any classes
    :param type_hint: if set it will be used to help determine what
                 object to deserialize in. It does not override if another
                 specification is found
    :return: object
    """
    ...
