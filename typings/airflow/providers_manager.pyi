"""
This type stub file was generated by pyright.
"""

import sys
from collections.abc import Callable, MutableMapping
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Any,
    NamedTuple,
    NoReturn,
    TypeVar,
)
from urllib.parse import SplitResult

from airflow.datasets import Dataset
from airflow.decorators.base import TaskDecorator
from airflow.typing_compat import Literal, ParamSpec
from airflow.utils.log.logging_mixin import LoggingMixin
from airflow.utils.singleton import Singleton

"""Manages all providers."""
log = ...
if sys.version_info >= (3, 9): ...
else: ...
PS = ParamSpec("PS")
RT = TypeVar("RT")
MIN_PROVIDER_VERSIONS = ...
if TYPE_CHECKING: ...

class LazyDictWithCache(MutableMapping):
    """
    Lazy-loaded cached dictionary.

    Dictionary, which in case you set callable, executes the passed callable with `key` attribute
    at first use - and returns and caches the result.
    """

    __slots__ = ...
    def __init__(self, *args, **kw) -> None: ...
    def __setitem__(self, key, value):  # -> None:
        ...
    def __getitem__(self, key):  # -> object:
        ...
    def __delitem__(self, key):  # -> None:
        ...
    def __iter__(self):  # -> Iterator[Any]:
        ...
    def __len__(self):  # -> int:
        ...
    def __contains__(self, key):  # -> bool:
        ...
    def clear(self):  # -> None:
        ...

@dataclass
class ProviderInfo:
    """
    Provider information.

    :param version: version string
    :param data: dictionary with information about the provider
    :param source_or_package: whether the provider is source files or PyPI package. When installed from
        sources we suppress provider import errors.
    """

    version: str
    data: dict
    package_or_source: Literal[source] | Literal[package]
    def __post_init__(self):  # -> None:
        ...

class HookClassProvider(NamedTuple):
    """Hook class and Provider it comes from."""

    hook_class_name: str
    package_name: str
    ...

class TriggerInfo(NamedTuple):
    """Trigger class and provider it comes from."""

    trigger_class_name: str
    package_name: str
    integration_name: str
    ...

class NotificationInfo(NamedTuple):
    """Notification class and provider it comes from."""

    notification_class_name: str
    package_name: str
    ...

class PluginInfo(NamedTuple):
    """Plugin class, name and provider it comes from."""

    name: str
    plugin_class: str
    provider_name: str
    ...

class HookInfo(NamedTuple):
    """Hook information."""

    hook_class_name: str
    connection_id_attribute_name: str
    package_name: str
    hook_name: str
    connection_type: str
    connection_testable: bool
    ...

class ConnectionFormWidgetInfo(NamedTuple):
    """Connection Form Widget information."""

    hook_class_name: str
    package_name: str
    field: Any
    field_name: str
    is_sensitive: bool
    ...

def log_debug_import_from_sources(class_name, e, provider_package):  # -> None:
    """Log debug imports from sources."""
    ...

def log_optional_feature_disabled(class_name, e, provider_package):  # -> None:
    """Log optional feature disabled."""
    ...

def log_import_warning(class_name, e, provider_package):  # -> None:
    """Log import warning."""
    ...

KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS = ...

def provider_info_cache(
    cache_name: str,
) -> Callable[[Callable[PS, NoReturn]], Callable[PS, None]]:
    """
    Decorate and cache provider info.

    Decorator factory that create decorator that caches initialization of provider's parameters
    :param cache_name: Name of the cache
    """
    ...

class ProvidersManager(LoggingMixin, metaclass=Singleton):
    """
    Manages all provider packages.

    This is a Singleton class. The first time it is
    instantiated, it discovers all available providers in installed packages and
    local source folders (if airflow is run from sources).
    """

    resource_version = ...
    _initialized: bool = ...
    _initialization_stack_trace = ...
    @staticmethod
    def initialized() -> bool: ...
    @staticmethod
    def initialization_stack_trace() -> str | None: ...
    def __init__(self) -> None:
        """Initialize the manager."""
        ...

    @provider_info_cache("list")
    def initialize_providers_list(self):  # -> None:
        """Lazy initialization of providers list."""
        ...

    @provider_info_cache("hooks")
    def initialize_providers_hooks(self):  # -> None:
        """Lazy initialization of providers hooks."""
        ...

    @provider_info_cache("filesystems")
    def initialize_providers_filesystems(self):  # -> None:
        """Lazy initialization of providers filesystems."""
        ...

    @provider_info_cache("dataset_uris")
    def initialize_providers_dataset_uri_resources(self):  # -> None:
        """Lazy initialization of provider dataset URI handlers, factories, converters etc."""
        ...

    @provider_info_cache("hook_lineage_writers")
    @provider_info_cache("taskflow_decorators")
    def initialize_providers_taskflow_decorator(self):  # -> None:
        """Lazy initialization of providers hooks."""
        ...

    @provider_info_cache("extra_links")
    def initialize_providers_extra_links(self):  # -> None:
        """Lazy initialization of providers extra links."""
        ...

    @provider_info_cache("logging")
    def initialize_providers_logging(self):  # -> None:
        """Lazy initialization of providers logging information."""
        ...

    @provider_info_cache("secrets_backends")
    def initialize_providers_secrets_backends(self):  # -> None:
        """Lazy initialization of providers secrets_backends information."""
        ...

    @provider_info_cache("executors")
    def initialize_providers_executors(self):  # -> None:
        """Lazy initialization of providers executors information."""
        ...

    @provider_info_cache("notifications")
    def initialize_providers_notifications(self):  # -> None:
        """Lazy initialization of providers notifications information."""
        ...

    @provider_info_cache("auth_managers")
    def initialize_providers_auth_managers(self):  # -> None:
        """Lazy initialization of providers notifications information."""
        ...

    @provider_info_cache("config")
    def initialize_providers_configuration(self):  # -> None:
        """Lazy initialization of providers configuration information."""
        ...

    @provider_info_cache("auth_backends")
    def initialize_providers_auth_backends(self):  # -> None:
        """Lazy initialization of providers API auth_backends information."""
        ...

    @provider_info_cache("plugins")
    def initialize_providers_plugins(self):  # -> None:
        ...
    @provider_info_cache("triggers")
    def initialize_providers_triggers(self):  # -> None:
        """Initialize providers triggers."""
        ...

    @property
    def auth_managers(self) -> list[str]:
        """Returns information about available providers notifications class."""
        ...

    @property
    def notification(self) -> list[NotificationInfo]:
        """Returns information about available providers notifications class."""
        ...

    @property
    def trigger(self) -> list[TriggerInfo]:
        """Returns information about available providers trigger class."""
        ...

    @property
    def providers(self) -> dict[str, ProviderInfo]:
        """Returns information about available providers."""
        ...

    @property
    def hooks(self) -> MutableMapping[str, HookInfo | None]:
        """
        Return dictionary of connection_type-to-hook mapping.

        Note that the dict can contain None values if a hook discovered cannot be imported!
        """
        ...

    @property
    def plugins(self) -> list[PluginInfo]:
        """Returns information about plugins available in providers."""
        ...

    @property
    def taskflow_decorators(self) -> dict[str, TaskDecorator]: ...
    @property
    def extra_links_class_names(self) -> list[str]:
        """Returns set of extra link class names."""
        ...

    @property
    def connection_form_widgets(self) -> dict[str, ConnectionFormWidgetInfo]:
        """
        Returns widgets for connection forms.

        Dictionary keys in the same order that it defined in Hook.
        """
        ...

    @property
    def field_behaviours(self) -> dict[str, dict]:
        """Returns dictionary with field behaviours for connection types."""
        ...

    @property
    def logging_class_names(self) -> list[str]:
        """Returns set of log task handlers class names."""
        ...

    @property
    def secrets_backend_class_names(self) -> list[str]:
        """Returns set of secret backend class names."""
        ...

    @property
    def auth_backend_module_names(self) -> list[str]:
        """Returns set of API auth backend class names."""
        ...

    @property
    def executor_class_names(self) -> list[str]: ...
    @property
    def filesystem_module_names(self) -> list[str]: ...
    @property
    def dataset_factories(self) -> dict[str, Callable[..., Dataset]]: ...
    @property
    def dataset_uri_handlers(
        self,
    ) -> dict[str, Callable[[SplitResult], SplitResult]]: ...
    @property
    def dataset_to_openlineage_converters(self) -> dict[str, Callable]: ...
    @property
    def provider_configs(self) -> list[tuple[str, dict[str, Any]]]: ...
    @property
    def already_initialized_provider_configs(
        self,
    ) -> list[tuple[str, dict[str, Any]]]: ...
